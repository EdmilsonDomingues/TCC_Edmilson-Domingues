import gurobipy as gp
import pandas as pd
import copy
import time
import sys
from prettytable import PrettyTable
from random import choice, shuffle

START_POINT = 0
END_POINT = None

instancia = input("Você quer trabalhar com 1 instância ou 129?")
if instancia == "1":
    # Leitura completa da tabela fornecida
    print('Realizando o processo de Leitura.')
    df = pd.read_excel('./arquivo_ProjetoUFSC_v1.ods', engine='odf')
    df['Código da disc. '] = df['Código da disc. '].astype(str)
    # print(df.dtypes)
    # print()
    df.head()
    print(df.info())
    print(df)
else:
    if instancia == "129" or instancia == "":
        # Leitura completa da tabela fornecida
        print('Realizando o processo de Leitura.')
        df = pd.read_csv('./arquivoProjetoUFSC_regionalFlorianopolis_modificado.csv', sep=';')
        df['Código da disc. '] = df['Código da disc. '].astype(str)
        print("Quantidade de registros: ", len(df.index))
        df.info()
        lista_escolas = []
        pares = []
        for indice, valor in df.iterrows():
            if valor[1] not in lista_escolas:
                lista_escolas.append(valor[1])
                pares.append([valor[1], valor[2]])
        lista_escolas.sort()
        for i in range(len(lista_escolas)):
            for j in range(len(pares)):
                if pares[j][0] == lista_escolas[i]:
                    print(i, '- Código escola: ', pares[j][0], '- Nome escola: ', pares[j][1])
        print()
        ordem = int(input("Entre com o número mais à esquerda para a escola de interesse: "))
        escola = 99998
        if ordem >= len(pares):
            print("ERRO: Valor fora do range.")
        else:
            for j in range(len(pares)):
                if pares[j][0] == lista_escolas[ordem]:
                    print(ordem, '- Código escola: ', pares[j][0], '- Nome escola: ', pares[j][1])
                    escola = pares[j][0]
                    break
        df = df[df["Cod. Esc."] == escola]
        print("Quantidade de registros da escola de interesse: ", len(df.index))
        # Observou-se que para a mesma turma-disciplina existiam horários de início-fim diferentes. Por isso
        # serão todos zerados, antes de verificar a duplicação.
        df["Início das aulas"] = "00:00"
        df["Fim das aulas"] = "00:00"
        df = df.drop_duplicates()
        print("Quantidade de registros após retirar duplicados: ", len(df.index))
        df_remove = df.loc[(df['Código da disc. '] == '1344') |
                           (df['Código da disc. '] == '2148') |
                           (df['Código da disc. '] == '3498') |
                           (df['Código da disc. '] == '3787') |
                           (df['Código da disc. '] == '4329') |
                           (df['Código da disc. '] == '4492') |
                           (df['Código da disc. '] == '611') |
                           (df['Código da disc. '] == '5011') |
                           (df['Código da disc. '] == '2473') |
                           (df['Código da disc. '] == '4330') |
                           (df['Código da disc. '] == '3790') |
                           (df['Código da disc. '] == '1155') |
                           (df['Código da disc. '] == '1701') |
                           (df['Código da disc. '] == '4543') |
                           (df['Código da disc. '] == '4546') |
                           (df['Código da disc. '] == '3464') |
                           (df['Código da disc. '] == '3332') |
                           (df['Código da disc. '] == '3319') |
                           (df['Código da disc. '] == '4006') |
                           (df['Código da disc. '] == '4005') |
                           (df['Código da disc. '] == '3312') |
                           (df['Código da disc. '] == '3311') |
                           (df['Código da disc. '] == '4636') |
                           (df['Código da disc. '] == '4510') |
                           (df['Código da disc. '] == '4509') |
                           (df['Código da disc. '] == '4013') |
                           (df['Código da disc. '] == '4547') |
                           (df['Código da disc. '] == '4205') |
                           (df['Código da disc. '] == '4207') |
                           (df['Código da disc. '] == '4214') |
                           (df['Código da disc. '] == '3468') |
                           (df['Código da disc. '] == '3463') |
                           (df['Código da disc. '] == '3313') |
                           (df['Código da disc. '] == '3319') |
                           (df['Código da disc. '] == '3321') |
                           (df['Código da disc. '] == '4247') |
                           (df['Código da disc. '] == '3318')]
        df = df.drop(df_remove.index)
        print("Quantidade de registros após retirar disciplinas FAKE: ", len(df.index))
        # Remover disciplinas excludentes:
        tem_lingua_estrangeira_ingles = False
        for indice, valor in df.iterrows():
            if valor[17] == '319':
                tem_lingua_estrangeira_ingles = True
                break
        if tem_lingua_estrangeira_ingles:
            df_remove = df.loc[(df['Código da disc. '] == '320') |
                               (df['Código da disc. '] == '321') |
                               (df['Código da disc. '] == '322') |
                               (df['Código da disc. '] == '323')]
            df = df.drop(df_remove.index)
        print("Quantidade de registros após retirar disciplinas excludentes: ", len(df.index))
        df['Número da turma'] = df['Número da turma'].astype(str) + '-' + df['Etapa (séries)'].astype(str)
        print(df['Número da turma'])
    else:
        print("Você não digitou uma informação válida.")
        sys.exit(0)
lista_turnos = []
for indice, valor in df.iterrows():
    if valor[8] not in lista_turnos:
        lista_turnos.append(valor[8])
print("---------------------------------------", lista_turnos)


class Turma:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, tipo_turma,
                 codigo_turno, turno, codigo_area_ensino, area_ensino, tipo_grade):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma  # PK
        self.tipo_turma = tipo_turma
        self.codigo_turno = codigo_turno
        self.turno = turno
        self.codigo_area_ensino = codigo_area_ensino
        self.area_ensino = area_ensino
        self.tipo_grade = tipo_grade

    def numero_turma(self):
        return self.numero_turma


class Disciplina:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, codigo_disciplina,
                 nome_disciplina, quantidade_aulas_semanais, codigo_area_ensino, area_ensino):
        self.matriz_curricular = matriz_curricular  # PK
        self.etapa_serie = etapa_serie  # PK
        self.numero_turma = numero_turma
        self.codigo_disciplina = codigo_disciplina  # PK
        self.nome_disciplina = nome_disciplina
        self.quantidade_aulas_semanais = quantidade_aulas_semanais
        self.codigo_area_ensino = codigo_area_ensino  # PK
        self.area_ensino = area_ensino

    def numero_turma(self):
        return self.numero_turma

    def codigo_disciplina(self):
        return self.codigo_disciplina

    def codigo_area_ensino(self):
        return self.codigo_area_ensino

    def quantidade_aulas_semanais(self):
        return self.quantidade_aulas_semanais


class Professor:
    def __init__(self, id_professor, cpf_professor, nome_professor):
        self.id_professor = id_professor
        self.cpf_professor = cpf_professor  # PK
        self.nome_professor = nome_professor

    def cpf_professor(self):
        return self.cpf_professor

    def nome_professor(self):
        return self.nome_professor


class Grade:
    def __init__(self, tipo_grade, turno):
        self.tipo_grade = tipo_grade
        self.turno = turno

    def grade_elementos(self):
        if self.tipo_grade == '1':
            if self.turno == 'todos':
                return ['1', ..., '51']
            else:
                pass
                if self.turno.upper() == 'MATUTINO':
                    return ['0', '1', '2', '3', '4', '15', '16', '17', '18',
                            '19', '30', '31', '32', '33', '34', '45', '46', '47', '48', '49',
                            '60', '61', '62', '63', '64']
                else:
                    if self.turno.upper() == 'VESPERTINO':
                        return ['5', '6', '7', '8', '9', '20', '21', '22',
                                '23', '24', '35', '36', '37', '38', '39', '50', '51', '52', '53', '54',
                                '65', '66', '67', '68', '69']
                    else:
                        if self.turno.upper() == 'NOTURNO':
                            return ['10', '11', '12', '13', '14', '25', '26', '27', '28', '29', '40', '41',
                                    '42', '43', '44', '55', '56', '57', '58', '59', '70', '71', '72', '73', '74']
                        else:
                            if self.turno.upper() == "INTEGRAL":
                                return ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '15', '16', '17', '18',
                                        '19', '20', '21', '22', '23', '24', '30', '31', '32', '33', '34', '35',
                                        '36', '37', '38', '39', '45', '46', '47', '48', '49', '50', '51', '52',
                                        '53', '54', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69']
                            else:
                                print("Deu outro turno.")
                                sys.exit(0)
        return None

    def janelas(self):
        return [['0', '1', '2'], ['1', '2', '3'], ['2', '3', '4'],
                ['5', '6', '7'], ['6', '7', '8'], ['7', '8', '9'],
                ['10', '11', '12'], ['11', '12', '13'], ['12', '13', '14'],
                ['15', '16', '17'], ['16', '17', '18'], ['17', '18', '19'],
                ['20', '21', '22'], ['21', '22', '23'], ['22', '23', '24'],
                ['25', '26', '27'], ['26', '27', '28'], ['27', '28', '29'],
                ['30', '31', '32'], ['31', '32', '33'], ['32', '33', '34'],
                ['35', '36', '37'], ['36', '37', '38'], ['37', '38', '39'],
                ['40', '41', '42'], ['41', '42', '43'], ['42', '43', '44'],
                ['45', '46', '47'], ['46', '47', '48'], ['47', '48', '49'],
                ['50', '51', '52'], ['51', '52', '53'], ['52', '53', '54'],
                ['55', '56', '57'], ['56', '57', '58'], ['57', '58', '59'],
                ['60', '61', '62'], ['61', '62', '63'], ['62', '63', '64'],
                ['65', '66', '67'], ['66', '67', '68'], ['67', '68', '69'],
                ['70', '71', '72'], ['71', '72', '73'], ['72', '73', '74']]

    def grade_vazia(self):
        gradevaz = [['07:30', '', '', '', '', ''],
                    ['08:15', '', '', '', '', ''],
                    ['09:00', '', '', '', '', ''],
                    ['10:05', '', '', '', '', ''],
                    ['10:50', '', '', '', '', ''],
                    ['*****', '*****', '*****', '*****', '*****', '*****'],
                    ['13:30', '', '', '', '', ''],
                    ['14:15', '', '', '', '', ''],
                    ['15:00', '', '', '', '', ''],
                    ['16:05', '', '', '', '', ''],
                    ['16:50', '', '', '', '', ''],
                    ['*****', '*****', '*****', '*****', '*****', '*****'],
                    ['18:30', '', '', '', '', ''],
                    ['19:10', '', '', '', '', ''],
                    ['19:50', '', '', '', '', ''],
                    ['20:40', '', '', '', '', ''],
                    ['21:20', '', '', '', '', '']]
        return gradevaz

    def dias_semana(self):
        pass
        lista_ds = [['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14'],
                    ['15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29'],
                    ['30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44'],
                    ['45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59'],
                    ['60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74']]
        return lista_ds

    def cabecalho(self):
        return ['Hora', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta']

    def converte_slot_lc(self, slot):
        lista_lc = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [6, 1], [7, 1], [8, 1], [9, 1], [10, 1], [12, 1], [13, 1],
                    [14, 1], [15, 1], [16, 1],
                    [0, 2], [1, 2], [2, 2], [3, 2], [4, 2], [6, 2], [7, 2], [8, 2], [9, 2], [10, 2], [12, 2], [13, 2],
                    [14, 2], [15, 2], [16, 2],
                    [0, 3], [1, 3], [2, 3], [3, 3], [4, 3], [6, 3], [7, 3], [8, 3], [9, 3], [10, 3], [12, 3], [13, 3],
                    [14, 3], [15, 3], [16, 3],
                    [0, 4], [1, 4], [2, 4], [3, 4], [4, 4], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [12, 4], [13, 4],
                    [14, 4], [15, 4], [16, 4],
                    [0, 5], [1, 5], [2, 5], [3, 5], [4, 5], [6, 5], [7, 5], [8, 5], [9, 5], [10, 5], [12, 5], [13, 5],
                    [14, 5], [15, 5], [16, 5]]
        return lista_lc[slot][0], lista_lc[slot][1]

    def conta_janelas(self, windows):
        janelas = self.janelas()
        numero_janelas = 0
        for m in range(len(janelas)):
            for n in range(len(windows)):
                if janelas[m][0] in windows[n] and janelas[m][1] not in windows[n] and janelas[m][2] in windows[n]:
                    numero_janelas = numero_janelas + 1
        return numero_janelas


class Slot:
    def __init__(self, slot):
        self._slot = slot

    @property
    def slot(self):
        return self._slot

    @slot.setter
    def slot(self, slot_novo):
        self._slot = slot_novo


class GrupoDisciplinas:
    def __init__(self, tipo_grupo, disciplinas):
        self.tipo_grupo = tipo_grupo
        self.disciplinas = disciplinas


# leitura dataframe escola e criação dos objetos correspondentes:
turmas_objetos = []
disciplinas_objetos = []
professores_objetos = []
slots_objetos = []

turmas_ponteiro = 0
disciplinas_ponteiro = 0
professores_ponteiro = 0
slots_ponteiro = 0
estrela_chaves = []

turma_prov = []
disciplina_prov = []
professor_prov = []
slot_prov = []

controle = []

for index, row in df.iterrows():
    if row['Código da disc. '] != '611' and row['Código da disc. '] != '1344':
        controle.clear()
        turma_prov.clear()
        disciplina_prov.clear()
        professor_prov.clear()

        turma_prov = [row['Matriz curricular'],
                      row['Etapa (séries)'],
                      row['Número da turma'],
                      row['Tipo de turma (prov. não usaremos)'],
                      row['Cod. Turno'],
                      row['Turno'],
                      row['Código da área de ensino'],
                      row['Área de ensino'], '1']
        disciplina_prov = [row['Matriz curricular'],
                           row['Etapa (séries)'],
                           row['Número da turma'],
                           row['Código da disc. '],
                           row['Nome da disc. '],
                           row['Qtd de aulas na semana'],
                           row['Código da área de ensino'],
                           row['Área de ensino']]
        professor_prov = [row['Identificador do prof. '],
                          row['CPF'],
                          row['Nome']]
        grade = Grade('1', turma_prov[5])
        slot_prov = grade.grade_elementos()

        in_turma = False
        indice = 0
        if len(turmas_objetos) > 0:
            for objeto in turmas_objetos:
                if turma_prov[2] == objeto.numero_turma and\
                        turma_prov[1] == objeto.etapa_serie and\
                        turma_prov[4] == objeto.codigo_turno and\
                        turma_prov[6] == objeto.codigo_area_ensino:
                    in_turma = True
                    break
                indice = indice + 1
        if in_turma:
            controle.append(indice)
        else:
            controle.append(turmas_ponteiro)
            turmas_objetos.append(Turma(turma_prov[0], turma_prov[1], turma_prov[2],
                                        turma_prov[3], turma_prov[4], turma_prov[5],
                                        turma_prov[6], turma_prov[7], turma_prov[8]))
            turmas_ponteiro = turmas_ponteiro + 1

        in_disciplina = False
        indice = 0
        if len(disciplinas_objetos) > 0:
            for objeto in disciplinas_objetos:
                if disciplina_prov[3] == objeto.codigo_disciplina \
                        and disciplina_prov[6] == objeto.codigo_area_ensino \
                        and disciplina_prov[1] == objeto.etapa_serie \
                        and disciplina_prov[0] == objeto.matriz_curricular:
                    in_disciplina = True
                    break
                indice = indice + 1
        if in_disciplina:
            controle.append(indice)
        else:
            controle.append(disciplinas_ponteiro)
            disciplinas_objetos.append(Disciplina(disciplina_prov[0], disciplina_prov[1], disciplina_prov[2],
                                                  disciplina_prov[3], disciplina_prov[4], disciplina_prov[5],
                                                  disciplina_prov[6], turma_prov[7]))
            disciplinas_ponteiro = disciplinas_ponteiro + 1

        in_professor = False
        indice = 0
        if len(professores_objetos) > 0:
            for objeto in professores_objetos:
                if professor_prov[1] == objeto.cpf_professor:
                    in_professor = True
                    break
                indice = indice + 1
        if in_professor:
            controle.append(indice)
        else:
            controle.append(professores_ponteiro)
            professores_objetos.append(Professor(professor_prov[0], professor_prov[1], professor_prov[2]))
            professores_ponteiro = professores_ponteiro + 1
        for slots in slot_prov:
            in_slot = False
            indice = 0
            if len(slots_objetos) > 0:
                for objeto in slots_objetos:
                    if slots == objeto.slot:
                        in_slot = True
                        break
                    indice = indice + 1
            if in_slot:
                lista = [controle[0], controle[1], controle[2], indice]
                if lista not in estrela_chaves:
                    estrela_chaves.append(lista)
            else:
                lista = [controle[0], controle[1], controle[2], slots_ponteiro]
                if lista not in estrela_chaves:
                    estrela_chaves.append(lista)
                    slots_objetos.append(Slot(slots))
                    slots_ponteiro = slots_ponteiro + 1
print("Len_estrelas: ", len(estrela_chaves))
print("Turmas_objetos: ", len(turmas_objetos))
print("Disciplinas_objetos: ", len(disciplinas_objetos))
print("Professores_objetos: ", len(professores_objetos))
print("Slots_objetos: ", len(slots_objetos))
for i in range(len(estrela_chaves)):
    if turmas_objetos[estrela_chaves[i][0]].numero_turma == '15-1':
        print(disciplinas_objetos[estrela_chaves[i][1]].codigo_disciplina,
              disciplinas_objetos[estrela_chaves[i][1]].nome_disciplina,
              disciplinas_objetos[estrela_chaves[i][1]].quantidade_aulas_semanais)
# [18/01/2023]
# Nesta parte do programa serão introduzidas as regras referentes à pesquisa operacional.
# 1) Variáveis do problema de Timetabling.
#
#      As listas "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos" são compostas
#      por objetos exclusivos, o que significa que, por exemplo, "turmas_objetos" possui todas as turmas da escola
#      que está sendo considerada.
#      Já a lista "estrela_chaves" possui todas as combinações possíveis para os elementos das listas
#      "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos". A estas combinações
#      serão consideradas variáveis para a esolução do problema.
#      Considerar X[t, d, p, s] como sendo a variável de interesse.

model = gp.Model("Timetabling")
# Variáveis da Pesquisa Operacional:
x_tdps = [i for i in range(len(estrela_chaves))]
x = model.addVars(x_tdps, vtype=gp.GRB.BINARY)
# Criação das variáveis Y:
pj = []  # tuplas professor-janela [p, s]
cont_pj = 0
buffer_s = []  # tdps associado a cada slot
s0 = []
s1 = []
s2 = []
somas = []
for i in range(len(slots_objetos)):
    buffer_s.append([])
for i in range(len(estrela_chaves)):
    estrela_chaves[i].append(i)
    buffer_s[estrela_chaves[i][3]].append(estrela_chaves[i])
grade = Grade('1', 'Matutino')
janelas = grade.janelas()
cont_ypj = 0
for professor in range(len(professores_objetos)):
    for jan in janelas:  # tuplas (s0, s1, s2)
        for fake in range(1):
            obj_existe = False
            for indice in range(len(slots_objetos)):
                if jan[0] == slots_objetos[indice].slot:
                    pos_s0 = indice
                    obj_existe = True
                    break
            if not obj_existe:
                break

            obj_existe = False
            for indice in range(len(slots_objetos)):
                if jan[1] == slots_objetos[indice].slot:
                    pos_s1 = indice
                    obj_existe = True
                    break
            if not obj_existe:
                break

            obj_existe = False
            for indice in range(len(slots_objetos)):
                if jan[2] == slots_objetos[indice].slot:
                    pos_s2 = indice
                    obj_existe = True
                    break
            if not obj_existe:
                break

            s0.clear()
            s1.clear()
            s2.clear()
            s0_existe = False
            s1_existe = False
            s2_existe = False
            for i in range(len(buffer_s[pos_s0])):
                if professor == buffer_s[pos_s0][i][2]:
                    s0.append(buffer_s[pos_s0][i][4])
                    s0_existe = True
            for i in range(len(buffer_s[pos_s1])):
                if professor == buffer_s[pos_s1][i][2]:
                    s1.append(buffer_s[pos_s1][i][4])
                    s1_existe = True
            for i in range(len(buffer_s[pos_s2])):
                if professor == buffer_s[pos_s2][i][2]:
                    s2.append(buffer_s[pos_s2][i][4])
                    s2_existe = True
            if s0_existe and s1_existe and s2_existe:
                somas.append([copy.deepcopy(s0), copy.deepcopy(s1), copy.deepcopy(s2)])
                pj.append([professor, jan])
                cont_pj = cont_pj + 1

y_pj = [i for i in range(len(pj))]
y = model.addVars(y_pj, vtype=gp.GRB.BINARY)
tolerancia = 0.0001
for cont in range(len(somas)):
    eps = 0.0001
    M = 10 + eps    # smallest possible given bounds on x and y

    model.addConstr(
        2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
        - 2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
        + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) >= 3 + eps
        - M * (1 - y[cont]), name="RESTRIÇÃO janelas >: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))
    model.addConstr(
        2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
        - 2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
        + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) <= 3 + eps
        + M * y[cont], name="RESTRIÇÃO janelas <: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))

# --------------------------------------------------------------------------------------------------------
# Função Objetivo da Pesquisa Operacional:
model.setObjective(gp.quicksum(y[i] for i in range(len(y_pj))), sense=gp.GRB.MINIMIZE)
# --------------------------------------------------------------------------------------------------------
# Restrições da Pesquisa Operacional:
inequacoes = []

# RESTRIÇÃO 2:
ts_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][3]] not in ts_lista:
        ts_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][3]])
tdps_lista = []
for ts in ts_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][3]] == ts:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        pass
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1, "RESTRIÇÃO 2: t_" + str(ts[0]) + " s_" + str(ts[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1, '2'])

# RESTRIÇÃO 3:
ps_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][2], estrela_chaves[cont][3]] not in ps_lista:
        ps_lista.append([estrela_chaves[cont][2], estrela_chaves[cont][3]])
tdps_lista = []
for ps in ps_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][2], estrela_chaves[cont][3]] == ps:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1,
                        "RESTRIÇÃO 3: p_" + str(ps[0]) + " s_" + str(ps[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1, '3'])

# RESTRIÇÃO 4:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
grade = Grade('1', 'Matutino')
ds_lista = grade.dias_semana()
dias = grade.cabecalho()
for i in range(5):
    lista_um_ds = ds_lista[i]
    for td in td_lista:
        tdps_lista.clear()
        razao = 5       # default = um valor alto.
        for cont in range(len(estrela_chaves)):
            if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
                resto = disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais % 5
                if resto == 0:
                    razao = int(disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais / 5)
                else:
                    razao = int(disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais / 5) + 1
                if slots_objetos[estrela_chaves[cont][3]].slot in lista_um_ds:
                    tdps_lista.append(cont)
        if len(tdps_lista) > 0:
            model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= razao,
                            "RESTRIÇÃO 4: t_" + str(td[0]) + " d_" + str(td[1]) + " ds_" + dias[i])
            inequacoes.append([copy.deepcopy(tdps_lista), razao, '4'])

# RESTRIÇÃO 6:
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
lista_disc = []
teste = 0
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    lista_disc.clear()
    for i in range(len(tdps_lista)):
        if [estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]] not in lista_disc:
            lista_disc.append([estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]])
    soma = 0
    for i in range(len(lista_disc)):
        soma = soma + disciplinas_objetos[lista_disc[i][1]].quantidade_aulas_semanais
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) == soma, "RESTRIÇÃO 6: p_" + str(p))
        inequacoes.append([copy.deepcopy(tdps_lista), soma, '6'])


# RESTRIÇÃO 7:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
for td in td_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) ==
                        disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]].quantidade_aulas_semanais,
                        "RESTRIÇÃO 7: t_" + str(td[0]) + " d_" + str(td[1]))
        inequacoes.append([copy.deepcopy(tdps_lista),
                           disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]].quantidade_aulas_semanais, '7'])

# --------------------------------------------------------------------------------------------------------
# Execução da modelagem:
model.optimize()
# print(model.display())
# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):
mostrar_nome_completo = False       # LGPD.
arquivo = open("grade completa da escola.txt", "w+")
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    lista_vizinhos = []     # Testes escrita "JANELA"
    for i in range(len(tdps_lista)):
        pass
        if 0.99 < x[tdps_lista[i]].X < 1.01:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            lista_vizinhos.append(slot_da_vez)  # Testes escrita "JANELA"
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "Turma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma) \
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina \
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info

    janelas_ref = grade.janelas()    # Testes escrita "JANELA"
    for i in range(len(slots_objetos)):
        slot_da_vez = int(slots_objetos[i].slot)
        for j in range(len(janelas_ref)):
            if slot_da_vez not in lista_vizinhos and int(janelas_ref[j][1]) == slot_da_vez:
                vizinho1 = int(janelas_ref[j][0])
                vizinho2 = int(janelas_ref[j][2])
                if vizinho1 in lista_vizinhos and vizinho2 in lista_vizinhos:
                    l, c = grade.converte_slot_lc(slot_da_vez)
                    info = nova_grade[l][c]
                    if info != "":
                        print("Algo errado.")
                        sys.exit(0)
                    else:
                        info = info + "** JANELA **"
                        nova_grade[l][c] = info

    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 5, cabecalho[1]: 28, cabecalho[2]: 28, cabecalho[3]: 28, cabecalho[4]: 28,
                               cabecalho[5]: 28}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('', file=arquivo)
    print('', file=arquivo)
    if mostrar_nome_completo:
        print('Professor(a): ', professores_objetos[p].nome_professor)
        print('Professor(a): ', professores_objetos[p].nome_professor, file=arquivo)
    else:
        nome_completo = professores_objetos[p].nome_professor.split()
        abreviacao = ''
        for i in range(len(nome_completo)):
            abreviacao = abreviacao + nome_completo[i][0]
        print('Professor(a): ', abreviacao)
        print(apresentacao)
        print('Professor(a): ', abreviacao, file=arquivo)
        print(apresentacao, file=arquivo)
t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        pass
        if 0.99 < x[tdps_lista[i]].X < 1.01:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            if mostrar_nome_completo:
                info = info + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                    + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                    + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            else:
                nome_completo = professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor.split()
                abreviacao = ''
                for j in range(len(nome_completo)):
                    abreviacao = abreviacao + nome_completo[j][0]
                info = info + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina \
                    + "\n" + "Professor(a): " + abreviacao\
                    + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 5, cabecalho[1]: 28, cabecalho[2]: 28, cabecalho[3]: 28, cabecalho[4]: 28,
                               cabecalho[5]: 28}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma:  ', turmas_objetos[t].numero_turma, "Área de Ensino: ", turmas_objetos[t].area_ensino)
    print(apresentacao)
    print('', file=arquivo)
    print('', file=arquivo)
    print('Turma:  ', turmas_objetos[t].numero_turma, "Área de Ensino: ", turmas_objetos[t].area_ensino, file=arquivo)
    print(apresentacao, file=arquivo)
    cont = 0
    print('len(x): ', len(x))
    for i in range(len(x)):
        if 0.99 < x[i].X < 1.01:
            cont = cont + 1
    print('Total de X: ', cont)
    print('len(y): ', len(y))
    cont = 0
    cont0 = 0
    for i in range(len(y)):
        if 0.99 < y[i].X < 1.01:
            cont = cont + 1
        else:
            if -0.01 < y[i].X < 0.01:
                cont0 = cont0 + 1
            else:
                print('O que tem em Y: ', y[i].X)
    print('Teste - Total de Y: ', cont)
    print('Teste - Total de Y zerado: ', cont0)

# --------------------------------------------------------------------------------------------------------
'''
# Recorrência se resultado for Unfeasible:

# model.write("model.ilp")

# From "https://www.gurobi.com/documentation/10.0/examples/workforce2_py.html#subsubsection:workforce2.py":
status = model.Status
if status == gp.GRB.UNBOUNDED:
    print('The model cannot be solved because it is unbounded')
    sys.exit(0)
if status == gp.GRB.OPTIMAL:
    print('The optimal objective is %g' % model.ObjVal)
    sys.exit(0)
if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
    print('Optimization was stopped with status %d' % status)
    sys.exit(0)

# do IIS
print('The model is infeasible; computing IIS')
removed = []

# Loop until we reduce to a model that can be solved
while True:

    model.computeIIS()
    print('\nThe following constraint cannot be satisfied:')
    for c in model.getConstrs():
        if c.IISConstr:
            print('%s' % c.ConstrName)
            # Remove a single constraint from the model
            removed.append(str(c.ConstrName))
            model.remove(c)
            break
    print('')

    model.optimize()
    status = model.Status

    if status == gp.GRB.UNBOUNDED:
        print('The model cannot be solved because it is unbounded')
        sys.exit(0)
    if status == gp.GRB.OPTIMAL:
        break
    if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
        print('Optimization was stopped with status %d' % status)
        sys.exit(0)

print('\nThe following constraints were removed to get a feasible LP:')
print(removed)
'''

# --------------------------------------------------------------------------------------------------------
# Neste ponto a estrutura de dados referente às inequações será transformada de lista para dicionário:
# --------------------------------------------------------------------------------------------------------
lista_tdps = []
lista_d = []
lista_p = []
lista_s = []
for t in range(len(turmas_objetos)):
    for d in range(len(disciplinas_objetos)):
        for p in range(len(professores_objetos)):
            for s in range(len(slots_objetos)):
                lista_s.append(99999)
            lista_p.append(lista_s)
            lista_s = []
        lista_d.append(lista_p)
        lista_p = []
    lista_tdps.append(lista_d)
    lista_d = []
for i in range(len(estrela_chaves)):
    lista_tdps[estrela_chaves[i][0]][estrela_chaves[i][1]][estrela_chaves[i][2]][estrela_chaves[i][3]] = i
# --------------------------------------------------------------------------------------------------------


class Individuo:
    def __init__(self, individuo):
        self.individuo = individuo
        self.solucao = []
        self.slot_problema = 0
        self.inequacoes = []
        self.lista_tdps = []
        self.dict = {}

    def individuo(self):
        return self.individuo

    def slot_problema(self):
        return self.slot_problema

    def testa_solucao(self, inequacoes, lista_tdps, dict_ponteiros, frame_tamanho, lista_indice_slots):
        dict_inequacoes = {}    # valor [1] associado à inequação apontada pelo ponteiro da vez
        for i in range(len(inequacoes)):
            dict_inequacoes[i] = inequacoes[i][1]
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                s = lista_indice_slots[f]
                valor_da_vez = lista_tdps[t][d][p][s]
                lista_ponteiros = dict_ponteiros[valor_da_vez]
                tem_7 = False
                tem_6 = False
                tem_4 = False
                tem_3 = False
                tem_2 = False
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '2':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_2 = True
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '3':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_3 = True
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '4':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_4 = True
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '6':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_6 = True
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '7':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_7 = True
                            break
                if tem_2 and tem_3 and tem_4 and tem_6 and tem_7:
                    # limpar inequações
                    for ponteiro in lista_ponteiros:
                        if dict_inequacoes[ponteiro] > 0 and valor_da_vez in inequacoes[ponteiro][0]:
                            dict_inequacoes[ponteiro] = dict_inequacoes[ponteiro] - 1
                else:
                    dict_inequacoes.clear()
                    return False
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                s = lista_indice_slots[f]
                valor_da_vez = lista_tdps[t][d][p][s]
                self.solucao.append(valor_da_vez)
        dict_inequacoes.clear()
        return True

    def solucao_frame(self):
        return self.solucao

    def fitness(self, inequacoes, lista_tdps, dict_ponteiros, frame_tamanho, lista_indice_slots):
        fitness = 0
        dict_inequacoes = {}    # valor [1] associado à inequação apontada pelo ponteiro da vez
        for i in range(len(inequacoes)):
            dict_inequacoes[i] = inequacoes[i][1]
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                s = lista_indice_slots[f]
                valor_da_vez = lista_tdps[t][d][p][s]
                lista_ponteiros = dict_ponteiros[valor_da_vez]
                delta = 0
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '2':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '3':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '4':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '6':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '7':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            break
                if delta < 5:
                    self.slot_problema = f  # possível slot com problema
                # limpar inequações
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and valor_da_vez in inequacoes[ponteiro][0]:
                        dict_inequacoes[ponteiro] = dict_inequacoes[ponteiro] - 1
        dict_inequacoes.clear()
        return fitness


# --------------------------------------------------------------------------------------------------------
# sys.exit(0)
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# #1: Estratégia = Encaixando peças
# Aqui neste bloco será aplicado um algoritmo genético, com a restrição de janelas.
# Hiperparâmetros:
n_individuos = 50
top_quantidade = 10
pc = 80
pm = 1
troca_n = 4
max_janelas_professor = 4
primeira_janela = 0
total_janelas = max_janelas_professor * len(professores_objetos)
passo_geracoes = 50
# ----------------- #
iteracoes = 0
tempo_1 = time.time()
# Neste ponto criaremos o buffer dos professores com os seus slots ocupados: [[0, 1, 25, 33], [2,4] ...]
# No exemplo, professor 0 ocupa slots 0, 1, 25 e 33.
windows = []
for i in range(len(professores_objetos)):
    windows.append([])

turmas_backup = []
turmas_creditos = []

# n_individuos = 50
range_n = []
for i in range(n_individuos):
    range_n.append(i)

range_25 = []
frame_tamanho = 25
for i in range(frame_tamanho):
    range_25.append(i)

range_100 = []
for i in range(1, 101):
    range_100.append(i)

range_10000 = []
for i in range(0, 10001):
    range_10000.append(i)

for i in range(len(turmas_objetos)):
    # N_individuos representa o número de indivíduos deste algoritmo genético
    frame_turno = ''
    frame_tuplas_tdp = []
    cred = 0

    turno_desta_turma = turmas_objetos[i].turno.upper()
    if turno_desta_turma == "INTEGRAL":
        frame_tamanho = 50
    else:
        frame_tamanho = 25

    for j in range(len(estrela_chaves)):
        tu = estrela_chaves[j][0]
        if tu == i:
            di = estrela_chaves[j][1]
            pr = estrela_chaves[j][2]
            if [tu, di, pr] not in frame_tuplas_tdp:
                cr = disciplinas_objetos[di].quantidade_aulas_semanais
                cred = cred + cr
                for w in range(cr):
                    frame_tuplas_tdp.append([tu, di, pr])
    if len(frame_tuplas_tdp) < frame_tamanho:
        falta = frame_tamanho - len(frame_tuplas_tdp)
        for k in range(falta):
            frame_tuplas_tdp.append(0)
    turmas_backup.append(frame_tuplas_tdp)
    turmas_creditos.append(cred)
lista_sorteados = []
parcial_janelas = 0
for t in range(len(turmas_objetos)):
    individuos = []  # n indivíduos (cada indivíduo, um frame)
    print('\nTurma: ', t)
    vez = 1
    temp_sorteados = []
    temp_entradas = copy.deepcopy(turmas_backup[t])
    # temp_inequacoes = copy.deepcopy(inequacoes)

    # melhorando performance
    temp_index = []
    for i in range(len(turmas_backup[t])):
        if turmas_backup[t][i] != 0:
            tt = turmas_backup[t][i][0]
            if turmas_objetos[tt].turno.upper() == 'MATUTINO':
                grade_padrao = Grade('1', 'MATUTINO')
                break
            else:
                if turmas_objetos[tt].turno.upper() == 'VESPERTINO':
                    grade_padrao = Grade('1', 'VESPERTINO')
                    break
                else:
                    if turmas_objetos[tt].turno.upper() == 'NOTURNO':
                        grade_padrao = Grade('1', 'NOTURNO')
                        break
                    else:
                        if turmas_objetos[tt].turno.upper() == 'INTEGRAL':
                            grade_padrao = Grade('1', 'INTEGRAL')
                            break
                        else:
                            print('Turno desconhecido.')
                            sys.exit(0)
    lista_numero_slots = grade_padrao.grade_elementos()
    lista_indice_slots = []
    for i in range(len(lista_numero_slots)):
        for j in range(len(slots_objetos)):
            if str(slots_objetos[j].slot) == lista_numero_slots[i]:
                if j not in lista_indice_slots:
                    lista_indice_slots.append(j)
    frame_tamanho = len(lista_indice_slots)

    range_frame_tamanho = []
    for i in range(frame_tamanho):
        range_frame_tamanho.append(i)

    for i in range(len(turmas_backup[t])):
        if turmas_backup[t][i] != 0:
            tt = turmas_backup[t][i][0]
            dd = turmas_backup[t][i][1]
            pp = turmas_backup[t][i][2]
            for ss in lista_indice_slots:
                valor = lista_tdps[tt][dd][pp][ss]
                if valor not in temp_index:
                    temp_index.append(valor)
    temp_inequacoes100 = []
    for i in range(len(temp_index)):
        for j in range(len(inequacoes)):
            if temp_index[i] in inequacoes[j][0]:
                diferentes = True
                for k in range(len(temp_inequacoes100)):
                    if inequacoes[j][0] == temp_inequacoes100[k][0] and\
                            inequacoes[j][1] == temp_inequacoes100[k][1] and \
                            inequacoes[j][2] == temp_inequacoes100[k][2]:
                        diferentes = False
                        break
                if diferentes:
                    temp_inequacoes100.append(inequacoes[j])
    temp_inequacoes = copy.deepcopy(temp_inequacoes100)

    dict_ponteiros = {}   # ponteiros
    for i in range(len(temp_inequacoes)):
        for j in range(len(temp_inequacoes[i][0])):
            if temp_inequacoes[i][0][j] not in dict_ponteiros:
                dict_ponteiros[temp_inequacoes[i][0][j]] = [i]
            else:
                dado = dict_ponteiros[temp_inequacoes[i][0][j]]
                dado.append(i)
                dict_ponteiros[temp_inequacoes[i][0][j]] = dado

    print('Tamanho entrada: ', turmas_creditos[t])
    max_fit = 6 * turmas_creditos[t]
    print('max_fit: ', max_fit)
    for i in range(len(turmas_backup[t])):
        if turmas_backup[t][i] != 0:
            tt = turmas_backup[t][i][0]
            print("Turno: ", turmas_objetos[tt].turno.upper())
            break
    populacao_atual = []
    temp = copy.deepcopy(turmas_backup[t])
    for i in range(n_individuos):
        for j in range(i + 2):
            shuffle(temp)
        populacao_atual.append(Individuo(copy.deepcopy(temp)))

    if t < primeira_janela:  # t começa em ZERO.
        # limite_fitness_janelas = 0
        max_janelas_t = 0
    else:
        # limite_fitness_janelas = ((t - primeira_janela) * (total_janelas - 1) //
        # ((len(turmas_objetos) - 1) - primeira_janela)) + 1
        max_janelas_t = ((t - primeira_janela) * (total_janelas - 1) //
                         ((len(turmas_objetos) - 1) - primeira_janela)) + 1
    print("Teste - max_janelas_t: ", max_janelas_t)
    limite_fitness_janelas = parcial_janelas
    print("Teste - limite_fitness_janelas: ", limite_fitness_janelas)
    contador_geracoes = 0
    status_fitness = 0
    status_janelas = 0

    # populações convergem aqui.
    finalizado = False
    while not finalizado:
        # Aqui vamos checar se a população atual não tem gêmeos:
        roda_a_roda = []
        for k in range(frame_tamanho):
            roda_a_roda.append(k)

        for i in range(len(populacao_atual)):
            for j in range(i+1, len(populacao_atual)):
                if i != j:
                    ind1 = copy.deepcopy(populacao_atual[i].individuo)
                    ind2 = copy.deepcopy(populacao_atual[j].individuo)
                    if ind1 != ind2:
                        pass
                    else:   # tem gêmeos / substituir 'j'
                        escolha = []
                        while len(escolha) != 6:
                            sorteio = choice(roda_a_roda)
                            if sorteio not in escolha:
                                escolha.append(sorteio)
                        for k in range(3):
                            temp = copy.deepcopy(ind2[escolha[0]])
                            ind2[escolha[0]] = ind2[escolha[1]]
                            ind2[escolha[1]] = temp
                            escolha.pop(0)
                            escolha.pop(0)
                        populacao_atual[j] = Individuo(copy.deepcopy(ind2))
        individuo_janelas = []
        for i in range(len(populacao_atual)):
            individuo_janelas.append(0)
        individuo_fitness = []
        for i in range(len(populacao_atual)):
            individuo_fitness.append(populacao_atual[i].fitness(temp_inequacoes, lista_tdps, dict_ponteiros,
                                                                frame_tamanho, lista_indice_slots))

        # Neste ponto realizamos a inclusão da restrição das janelas no cálculo do fitness.
        windows2 = []
        numero_janelas2 = limite_fitness_janelas + 1
        for i in range(len(populacao_atual)):
            windows2 = copy.deepcopy(windows)
            pontos_fitness = turmas_creditos[t]
            for j in range(frame_tamanho):
                numero_janelas = 0
                lista = populacao_atual[i].individuo
                if lista[j] != 0:
                    tt = lista[j][0]
                    p = lista[j][2]
                    ss = slots_objetos[lista_indice_slots[j]].slot
                    if ss not in windows2[p]:
                        windows2[p].append(ss)
                        windows2[p].sort()
                    grade = Grade('1', 'Matutino')
                    numero_janelas2 = grade.conta_janelas(windows2)
                    individuo_janelas[i] = numero_janelas2

            if numero_janelas2 <= limite_fitness_janelas:
                individuo_fitness[i] = individuo_fitness[i] + pontos_fitness

        # Vamos isolar os melhores da população, mantendo-os na população nova.
        print(vez, ' Turma:', t, 'indivíduo_fitness|janelas: ', end="")
        for i in range(len(populacao_atual)):
            if i == top_quantidade:
                print("  |", end="")
            print(str(individuo_fitness[i]) + "_" + str(individuo_janelas[i]) + "|", end="")
        print()
        # Aqui começa a tentativa de se implementar o que estou chamando de engenharia genética ou
        # manipulação genética.
        # Populações com fitness = máximo - 1 devem ser analisadas separadamente, no sentido de se
        # finalizar a busca por solução.
        # top_quantidade = 8
        for i in range(len(populacao_atual)):
            if i >= top_quantidade:
                if individuo_fitness[i] == max_fit - 1:
                    temp_populacao = copy.deepcopy(populacao_atual[i])
                    temp_populacao.fitness(
                        temp_inequacoes, lista_tdps, dict_ponteiros,
                        frame_tamanho, lista_indice_slots)      # para descobrir qual o slot com problema
                    slotcomproblema = temp_populacao.slot_problema
                    tdp = temp_populacao.individuo
                    for j in range(frame_tamanho):
                        if j != slotcomproblema:
                            temp_list = copy.deepcopy(temp_populacao.individuo)
                            temp_slot = temp_list[j]
                            temp_list[j] = temp_list[slotcomproblema]
                            temp_list[slotcomproblema] = temp_slot
                            nova_populacao = Individuo(temp_list)

                            dentro_janelas = False
                            windows2 = copy.deepcopy(windows)
                            pontos_fitness = turmas_creditos[t]
                            for k in range(frame_tamanho):
                                numero_janelas = 0
                                if temp_list[k] != 0:
                                    tt = temp_list[k][0]
                                    p = temp_list[k][2]
                                    ss = slots_objetos[lista_indice_slots[k]].slot
                                    if ss not in windows2[p]:
                                        windows2[p].append(ss)
                                        windows2[p].sort()
                                    grade = Grade('1', 'Matutino')
                                    numero_janelas2 = grade.conta_janelas(windows2)
                            dentro_janelas = False
                            if numero_janelas2 <= limite_fitness_janelas:
                                dentro_janelas = True

                            if dentro_janelas and nova_populacao.fitness(
                                    temp_inequacoes, lista_tdps, dict_ponteiros,
                                    frame_tamanho, lista_indice_slots) == max_fit - turmas_creditos[t]:
                                print(
                                    'Encontrei solução através de manipulação genética.', 'i: ', i,
                                    "número de janelas: ", numero_janelas2)
                                populacao_atual[i] = copy.deepcopy(nova_populacao)
                                individuo_fitness[i] = max_fit
                                individuo_janelas[i] = numero_janelas2
                                break
        pass
        temp_top = []
        grupo_melhores_fitnesses = []
        top = []
        for i in range(len(individuo_fitness)):
            if individuo_fitness[i] not in grupo_melhores_fitnesses:
                grupo_melhores_fitnesses.append(individuo_fitness[i])
        grupo_melhores_fitnesses.sort()
        grupo_melhores_fitnesses.reverse()
        for i in range(len(grupo_melhores_fitnesses)):
            menores_janelas = []
            for j in range(len(individuo_fitness)):
                if grupo_melhores_fitnesses[i] == individuo_fitness[j]:
                    temp_top.append([populacao_atual[j], individuo_janelas[j]])
                    menores_janelas.append(individuo_janelas[j])
            menores_janelas.sort()
            for j in range(len(menores_janelas)):
                for k in range(len(temp_top)):
                    if menores_janelas[j] == temp_top[k][1]:
                        top.append(temp_top[k][0])
                        del temp_top[k]
                        break
        top.reverse()
        while len(top) > top_quantidade:
            top.pop(0)
        top.reverse()
        # Expandir o resultado absoluto do fitness para resultado relativo do fitness, tomando
        #       como referência o menor valor [normalização].
        referencia = 500
        for i in range(len(populacao_atual)):
            if individuo_fitness[i] < referencia:
                referencia = individuo_fitness[i]
        pass
        # Aqui começa a seleção
        # Para selecionar é preciso transformar o valor de fitness em uma escala de 0-10000.
        total = 0
        for i in range(len(populacao_atual)):
            total = total + individuo_fitness[i]
        roleta_range = []
        for i in range(len(populacao_atual)):
            if i == 0:
                inicio = 0
            else:
                inicio = roleta_range[i-1][1]
            # fim = inicio + (individuo_fitness[i] * 10000 / total)
            if total != 0:
                fim = inicio + (individuo_fitness[i] * 10000 / total)
            else:
                inicio = 0
                fim = 10000
            roleta_range.append([inicio, fim])
        selecionados = []
        for i in range(len(populacao_atual)):
            valor = choice(range_10000)
            for j in range(len(populacao_atual)):
                if roleta_range[j][0] <= valor <= roleta_range[j][1]:
                    selecionados.append(populacao_atual[j])
        pass
        # Neste ponto temos os selecionados.
        lista_crossover = []
        nao_lista_crossover = []
        for i in range(len(selecionados)):
            valor = choice(range_100)
            if valor <= pc:
                lista_crossover.append(selecionados[i])
            else:
                nao_lista_crossover.append(selecionados[i])
        # Verificar se número ímpar de selecionados:
        if len(lista_crossover) % 2 == 0:
            pass
        else:
            tamanho_lista = len(lista_crossover)
            indice = tamanho_lista - 1
            valor = lista_crossover[indice]
            nao_lista_crossover.append(valor)
            lista_crossover.pop(indice)
        # Realizar crossover (position-based crossover)
        # Critério: trocar o conteúdo de posições e manter as outras
        # Então vamos sortear as posições que serão embaralhadas
        troca_n = 4
        range_troca = []
        while len(range_troca) != troca_n:
            sorte = choice(range_frame_tamanho)
            if sorte not in range_troca:
                range_troca.append(sorte)
        # Vamos gerar os filhos.
        filhos = []
        for i in range(int(len(lista_crossover) / 2)):
            iguais = True
            conta_iguais = 0
            while iguais:
                if conta_iguais < 5:
                    corte1 = choice(range_frame_tamanho)
                    corte2 = corte1
                    while corte2 == corte1:
                        corte2 = choice(range_frame_tamanho)
                    if corte2 < corte1:
                        temp = corte2
                        corte2 = corte1
                        corte1 = temp
                    filho1_copia = []
                    pai1_exclusivo = []
                    filho2_copia = []
                    pai2_exclusivo = []
                    if corte1 == corte2:
                        pass
                    else:
                        cross0 = lista_crossover[2 * i].individuo
                        cross1 = lista_crossover[2 * i + 1].individuo
                        for j in range(frame_tamanho):
                            if corte1 < j <= corte2:
                                filho1_copia.append(cross0[j])
                                filho2_copia.append(cross1[j])
                            else:
                                pai1_exclusivo.append(cross0[j])
                                pai2_exclusivo.append(cross1[j])
                    pai1_todo_sequencial = []
                    pai2_todo_sequencial = []
                    if cross0 == cross1:
                        for j in range(corte2 + 1, corte2 + 1 + frame_tamanho):
                            pai1_todo_sequencial.append(cross0[j % frame_tamanho])
                            pai2_todo_sequencial.append(cross1[j % frame_tamanho])
                    else:
                        for j in range(frame_tamanho):
                            pai1_todo_sequencial.append(cross0[j])
                            pai2_todo_sequencial.append(cross1[j])
                    pai2_resto = []
                    for j in range(len(pai2_todo_sequencial)):
                        if pai2_todo_sequencial[j] in pai1_exclusivo:
                            pai2_resto.append(pai2_todo_sequencial[j])
                            pai1_exclusivo.remove(pai2_todo_sequencial[j])
                    pai1_resto = []
                    for j in range(len(pai1_todo_sequencial)):
                        if pai1_todo_sequencial[j] in pai2_exclusivo:
                            pai1_resto.append(pai1_todo_sequencial[j])
                            pai2_exclusivo.remove(pai1_todo_sequencial[j])
                    filho1_total = []
                    for j in range(frame_tamanho):
                        if corte1 != corte2:
                            if corte1 < j <= corte2:
                                filho1_total.append(filho1_copia[0])
                                filho1_copia.pop(0)
                            else:
                                filho1_total.append(pai2_resto[0])
                                pai2_resto.pop(0)
                        else:
                            filho1_total.append(cross0[j])
                    filho2_total = []
                    for j in range(frame_tamanho):
                        if corte1 != corte2:
                            if corte1 < j <= corte2:
                                filho2_total.append(filho2_copia[0])
                                filho2_copia.pop(0)
                            else:
                                filho2_total.append(pai1_resto[0])
                                pai1_resto.pop(0)
                        else:
                            filho2_total.append(cross0[j])
                    conta_iguais = conta_iguais + 1
                    if filho1_total != cross0 and filho1_total != cross1 and\
                            filho2_total != cross0 and filho2_total != cross1:
                        iguais = False
                else:
                    iguais = False  # embora iguais, simula serem diferentes para poder passar adiante.
            filhos.append(filho1_total)
            filhos.append(filho2_total)
            if filho1_total == cross0:
                print('Filho 0 igual cross0. ')
            if filho1_total == cross1:
                print('Filho 0 igual cross1. ')
            if filho2_total == cross0:
                print('Filho 1 igual cross0. ')
            if filho2_total == cross1:
                print('Filho 1 igual cross1. ')
        # Realizar mutação (order-based mutation).
        # Varrer posições e aplicar Bernoulli (pm)
        # Se posição for sofrer mutação, sortear outra posição para realizar a troca
        for i in range(len(filhos)):
            for j in range(frame_tamanho):
                valor = choice(range_100)
                if valor <= pm:
                    temp = filhos[i][j]
                    dest = j
                    while dest == j:
                        dest = choice(range_frame_tamanho)
                    filhos[i][j] = filhos[i][dest]
                    filhos[i][dest] = temp
        # Agora junta top, filhos e não escolhidos
        populacao_atual = []
        for i in range(top_quantidade):
            populacao_atual.append(top[i])
        for i in range(len(filhos)):
            populacao_atual.append(Individuo(filhos[i]))
        for i in range(len(nao_lista_crossover)):
            populacao_atual.append(nao_lista_crossover[i])
        populacao_atual.reverse()
        while len(populacao_atual) > n_individuos:
            populacao_atual.pop(0)
        populacao_atual.reverse()
        if len(populacao_atual) < n_individuos:
            print("populacao_atual tem menos que n_individuos.")

        # Verifica se resultados até aqui são consistentes:
        for i in range(n_individuos):
            # ref_i = []
            ref_i = copy.deepcopy(populacao_atual[i].individuo)
            # ref_j = []
            ref_j = copy.deepcopy(temp_entradas)
            while len(ref_i) != 0:
                if ref_i[0] in ref_j:
                    ref_j.remove(ref_i[0])
                    ref_i.pop(0)
                else:
                    print('Não são iguais.')
                    sys.exit(0)
        # Agora é testar se algum indivíduo é resultado válido.
        finalizado = False
        for i in range(len(populacao_atual)):
            if i >= top_quantidade:
                break
            dentro_janelas = False
            windows2 = copy.deepcopy(windows)
            pontos_fitness = turmas_creditos[t]
            for j in range(frame_tamanho):
                numero_janelas = 0
                lista = populacao_atual[i].individuo
                if lista[j] != 0:
                    tt = lista[j][0]
                    p = lista[j][2]
                    ss = slots_objetos[lista_indice_slots[j]].slot
                    if ss not in windows2[p]:
                        windows2[p].append(ss)
                        windows2[p].sort()
                    grade = Grade('1', 'Matutino')
                    numero_janelas2 = grade.conta_janelas(windows2)

            if numero_janelas2 <= limite_fitness_janelas:
                dentro_janelas = True
            tem_solucao = False
            if dentro_janelas:
                tem_solucao = populacao_atual[i].testa_solucao(temp_inequacoes, lista_tdps, dict_ponteiros,
                                                               frame_tamanho, lista_indice_slots)
            if tem_solucao:
                finalizado = True
                solucao = populacao_atual[i].solucao_frame()
                break
        if finalizado:
            for i in range(len(solucao)):
                lista_sorteados.append(solucao[i])
                pp = estrela_chaves[solucao[i]][2]
                ss = slots_objetos[estrela_chaves[solucao[i]][3]].slot
                if ss not in windows[pp]:
                    windows[pp].append(ss)
                for j in range(len(inequacoes)):
                    if inequacoes[j][1] > 0 and solucao[i] in inequacoes[j][0]:
                        inequacoes[j][1] = inequacoes[j][1] - 1
            finalizado = True
            print(vez, '*Turma:', t, 'indivíduo_fitness|janelas: ', end="")
            for i in range(len(populacao_atual)):
                if i == top_quantidade:
                    print("  |", end="")
                print(str(individuo_fitness[i]) + "_" + str(individuo_janelas[i]) + "|", end="")
            print()
            print('Gerações nesta turma: -----------------------------', vez)
            iteracoes = iteracoes + vez

            grade_rodada = Grade('1', 'Matutino')
            parcial_janelas = grade_rodada.conta_janelas(windows)
            print('Janelas totais: ', parcial_janelas)
            tempo_2 = time.time()
            intervalo = (tempo_2 - tempo_1) / 60
            print(iteracoes, ' gerações totais.')
            print(intervalo, ' minutos até aqui.')
        else:
            vez = vez + 1
            if individuo_fitness[0] != status_fitness or individuo_janelas[0] != status_janelas:
                contador_geracoes = 0
                print("                  ----------------------")
                status_fitness = individuo_fitness[0]
                status_janelas = individuo_janelas[0]
            else:
                if contador_geracoes >= passo_geracoes:
                    print("Teste - estourou contador.")
                    if limite_fitness_janelas < max_janelas_t:
                        limite_fitness_janelas = limite_fitness_janelas + 1
                        print("Teste - novo limite de janelas: ", limite_fitness_janelas, "Máximo: ", max_janelas_t)
                        contador_geracoes = 0
                        print("                  ----------------------")
                        status_fitness = individuo_fitness[0]
                        status_janelas = individuo_janelas[0]
                else:
                    contador_geracoes = contador_geracoes + 1
            temp_sorteados = []
            temp_entradas = copy.deepcopy(turmas_backup[t])
            temp_inequacoes = copy.deepcopy(temp_inequacoes100)

            dict = {}  # dict_temp_inequacoes
            for i in range(len(temp_inequacoes)):
                for j in range(len(temp_inequacoes[i][0])):
                    if temp_inequacoes[i][0][j] not in dict:
                        dict[temp_inequacoes[i][0][j]] = [i]
                    else:
                        dado = dict[temp_inequacoes[i][0][j]]
                        dado.append(i)
                        dict[temp_inequacoes[i][0][j]] = dado

            finalizado = False
for i in range(len(windows)):
    windows[i].sort()
xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(y)):
    if y[i].X == 1:
        cont = cont + 1
print('Total de Y: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
tempo_2 = time.time()
intervalo = (tempo_2 - tempo_1) / 60
print(iteracoes, ' gerações finais.')
print(intervalo, ' minutos.')

# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):
# Para o AG.
# sys.exit(0)
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    lista_vizinhos = []     # Testes escrita "JANELA"
    for i in range(len(tdps_lista)):
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            lista_vizinhos.append(slot_da_vez)  # Testes escrita "JANELA"
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "\n\nTurma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma)\
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info

    janelas_ref = grade.janelas()    # Testes escrita "JANELA"
    for i in range(len(slots_objetos)):
        slot_da_vez = int(slots_objetos[i].slot)
        for j in range(len(janelas_ref)):
            if slot_da_vez not in lista_vizinhos and int(janelas_ref[j][1]) == slot_da_vez:
                vizinho1 = int(janelas_ref[j][0])
                vizinho2 = int(janelas_ref[j][2])
                if vizinho1 in lista_vizinhos and vizinho2 in lista_vizinhos:
                    l, c = grade.converte_slot_lc(slot_da_vez)
                    info = nova_grade[l][c]
                    if info != "":
                        print("Algo errado.")
                        sys.exit(0)
                    else:
                        info = info + "*** JANELA ***"
                        nova_grade[l][c] = info

    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 5, cabecalho[1]: 28, cabecalho[2]: 28, cabecalho[3]: 28, cabecalho[4]: 28,
                               cabecalho[5]: 28}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Professor(a) - heurística: ', professores_objetos[p].nome_professor)
    print(apresentacao)

t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "\n\nDisciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 5, cabecalho[1]: 28, cabecalho[2]: 28, cabecalho[3]: 28, cabecalho[4]: 28,
                               cabecalho[5]: 28}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma - heurística: ', turmas_objetos[t].numero_turma)
    print(apresentacao)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
print(lista_sorteados)
# --------------------------------------------------------------------------------------------------------
