import gurobipy as gp
import pandas as pd
import copy
import time
import sys
from prettytable import PrettyTable
from random import choice, shuffle, random

START_POINT = 0
END_POINT = None
'''
lista_turnos_por_escola = []
df = pd.read_csv('./arquivoProjetoUFSC_regionalFlorianopolis_modificado.csv', sep = ';')
df['Código da disc. '] = df['Código da disc. '].astype(str)
lista_turnos_por_escola = []
for indice, valor in df.iterrows():
    esta_na_lista = False
    posicao = 0
    for j in range(len(lista_turnos_por_escola)):
        if valor[1] == lista_turnos_por_escola[j][0]:
            esta_na_lista = True
            posicao = j
            break
    if esta_na_lista:
        if valor[8] not in lista_turnos_por_escola[posicao][2]:
            lista_turnos_por_escola[posicao][2].append(valor[8])
    else:
        lista_prov = [valor[1], valor[2], [valor[8]]]
        lista_turnos_por_escola.append(lista_prov)
for i in range(len(lista_turnos_por_escola)):
    print(lista_turnos_por_escola[i])
sys.exit(0)
'''

instancia = input("Você quer trabalhar com 1 instância ou 129?")
if instancia == "1":
    # Leitura completa da tabela fornecida
    print('Realizando o processo de Leitura.')
    df = pd.read_excel('./arquivo_ProjetoUFSC_v1.ods', engine='odf')
    df['Código da disc. '] = df['Código da disc. '].astype(str)
    # print(df.dtypes)
    # print()
    df.head()
    print(df.info())
    print(df)
else:
    if instancia == "129" or instancia == "":
        # Leitura completa da tabela fornecida
        print('Realizando o processo de Leitura.')
        df = pd.read_csv('./arquivoProjetoUFSC_regionalFlorianopolis_modificado.csv', sep = ';')
        df['Código da disc. '] = df['Código da disc. '].astype(str)
        print("Quantidade de registros: ", len(df.index))
        df.info()
        lista_escolas = []
        pares = []
        for indice, valor in df.iterrows():
            if valor[1] not in lista_escolas:
                lista_escolas.append(valor[1])
                pares.append([valor[1], valor[2]])
        lista_escolas.sort()
        for i in range(len(lista_escolas)):
            for j in range(len(pares)):
                if pares[j][0] == lista_escolas[i]:
                    print(i, '- Código escola: ', pares[j][0], '- Nome escola: ', pares[j][1])
        print()
        ordem = int(input("Entre com o número mais à esquerda para a escola de interesse: "))
        if ordem >= len(pares):
            print("ERRO: Valor fora do range.")
        else:
            for j in range(len(pares)):
                if pares[j][0] == lista_escolas[ordem]:
                    print(ordem, '- Código escola: ', pares[j][0], '- Nome escola: ', pares[j][1])
                    escola = pares[j][0]
                    break
        df = df[df["Cod. Esc."] == escola]
        print("Quantidade de registros da escola de interesse: ", len(df.index))
        # Observou-se que para a mesma turma-disciplina existiam horários de início-fim diferentes. Por isso
        # serão todos zerados, antes de verificar a duplicação.
        df["Início das aulas"] = "00:00"
        df["Fim das aulas"] = "00:00"
        df = df.drop_duplicates()
        print("Quantidade de registros após retirar duplicados: ", len(df.index))
        df_remove = df.loc[(df['Código da disc. '] == '1344') | \
                            (df['Código da disc. '] == '2148') | \
                            (df['Código da disc. '] == '3498') | \
                            (df['Código da disc. '] == '3787') | \
                            (df['Código da disc. '] == '4329') | \
                            (df['Código da disc. '] == '4492') | \
                            (df['Código da disc. '] == '611') | \
                            (df['Código da disc. '] == '5011') | \
                            (df['Código da disc. '] == '2473') | \
                            (df['Código da disc. '] == '4330') | \
                            (df['Código da disc. '] == '3790') | \
                            (df['Código da disc. '] == '1155') | \
                            (df['Código da disc. '] == '3318')]
        df = df.drop(df_remove.index)
        df['Número da turma'] = df['Número da turma'].astype(str) + '-' + df['Etapa (séries)'].astype(str)
        print("Quantidade de registros após retirar segundo professor: ", len(df.index))
        for indice, valor in df.iterrows():
            print(valor)
        print(df['Número da turma'])
    else:
        print("Você não digitou uma informação válida.")
        sys.exit(0)
lista_turnos = []
for indice, valor in df.iterrows():
    if valor[8] not in lista_turnos:
        lista_turnos.append(valor[8])
print("---------------------------------------", lista_turnos)


class Turma:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, tipo_turma,
                 codigo_turno, turno, codigo_area_ensino, area_ensino, tipo_grade):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma  # PK
        self.tipo_turma = tipo_turma
        self.codigo_turno = codigo_turno
        self.turno = turno
        self.codigo_area_ensino = codigo_area_ensino
        self.area_ensino = area_ensino
        self.tipo_grade = tipo_grade

    def numero_turma(self):
        return self.numero_turma


class Disciplina:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, codigo_disciplina,
                 nome_disciplina, quantidade_aulas_semanais, codigo_area_ensino, area_ensino):
        self.matriz_curricular = matriz_curricular  # PK
        self.etapa_serie = etapa_serie  # PK
        self.numero_turma = numero_turma
        self.codigo_disciplina = codigo_disciplina  # PK
        self.nome_disciplina = nome_disciplina
        self.quantidade_aulas_semanais = quantidade_aulas_semanais
        self.codigo_area_ensino = codigo_area_ensino  # PK
        self.area_ensino = area_ensino

    def numero_turma(self):
        return self.numero_turma

    def codigo_disciplina(self):
        return self.codigo_disciplina

    def codigo_area_ensino(self):
        return self.codigo_area_ensino

    def quantidade_aulas_semanais(self):
        return self.quantidade_aulas_semanais


class Professor:
    def __init__(self, id_professor, cpf_professor, nome_professor):
        self.id_professor = id_professor
        self.cpf_professor = cpf_professor  # PK
        self.nome_professor = nome_professor

    def cpf_professor(self):
        return self.cpf_professor

    def nome_professor(self):
        return self.nome_professor


class Grade:
    def __init__(self, tipo_grade, turno):
        self.tipo_grade = tipo_grade
        self.turno = turno

    def grade_elementos(self):
        if self.tipo_grade == '1':
            if self.turno == 'todos':
                return ['1', ..., '51']
            else:
                pass
                '''
                if self.turno.upper() == 'MATUTINO': # if self.turno == 'Matutino':
                    return ['0', '1', '2', '3', '4', '11', '12', '13', '14',
                            '15', '22', '23', '24', '25', '26', '33', '34',
                            '35', '36', '37', '44', '45', '46', '47', '48']
                else:
                    if self.turno.upper() == 'VESPERTINO':  #if self.turno == 'Vespertino':
                        return ['5', '6', '7', '8', '9', '16', '17', '18',
                                '19', '20', '27', '28', '29', '30', '31', '38',
                                '39', '40', '41', '42', '49', '50', '51', '52', '53']
                    else:
                        return ['10', '21', '32', '43', '54']
                '''
                if self.turno.upper() == 'MATUTINO': # if self.turno == 'Matutino':
                    return ['0', '1', '2', '3', '4', '15', '16', '17', '18',
                            '19', '30', '31', '32', '33', '34', '45', '46', '47', '48', '49',
                            '60', '61', '62', '63', '64']
                else:
                    if self.turno.upper() == 'VESPERTINO':  #if self.turno == 'Vespertino':
                        return ['5', '6', '7', '8', '9', '20', '21', '22',
                                '23', '24', '35', '36', '37', '38', '39', '50', '51', '52', '53', '54',
                                '65', '66', '67', '68', '69']
                    else:
                        if self.turno.upper() == 'NOTURNO':
                            return ['10', '11', '12', '13', '14', '25', '26', '27', '28', '29', '40', '41',
                                    '42', '43', '44', '55', '56', '57', '58', '59', '70', '71', '72', '73', '74']
                        else:
                            if self.turno.upper() == "INTEGRAL":
                                return ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '15', '16', '17', '18',
                                        '19', '20', '21', '22', '23', '24', '30', '31', '32', '33', '34', '35',
                                        '36', '37', '38', '39', '45', '46', '47', '48', '49', '50', '51', '52',
                                        '53', '54', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69']
                            else:
                                print("Deu outro turno.")
                                sys.exit(0)
        '''
        else:
            if self.tipo_grade == '2':
        '''
        return None

    def janelas(self):
        pass
        '''
        return [['0', '1', '2'], ['1', '2', '3'], ['2', '3', '4'],
                ['5', '6', '7'], ['6', '7', '8'], ['7', '8', '9'],
                ['11', '12', '13'], ['12', '13', '14'], ['13', '14', '15'],
                ['16', '17', '18'], ['17', '18', '19'], ['18', '19', '20'],
                ['22', '23', '24'], ['23', '24', '25'], ['24', '25', '26'],
                ['27', '28', '29'], ['28', '29', '30'], ['29', '30', '31'],
                ['33', '34', '35'], ['34', '35', '36'], ['35', '36', '37'],
                ['38', '39', '40'], ['39', '40', '41'], ['40', '41', '42'],
                ['44', '45', '46'], ['45', '46', '47'], ['46', '47', '48'],
                ['49', '50', '51'], ['50', '51', '52'], ['51', '52', '53']]
        '''
        return [['0', '1', '2'], ['1', '2', '3'], ['2', '3', '4'],
                ['5', '6', '7'], ['6', '7', '8'], ['7', '8', '9'],
                ['10', '11', '12'], ['11', '12', '13'], ['12', '13', '14'],
                ['15', '16', '17'], ['16', '17', '18'], ['17', '18', '19'],
                ['20', '21', '22'], ['21', '22', '23'], ['22', '23', '24'],
                ['25', '26', '27'], ['26', '27', '28'], ['27', '28', '29'],
                ['30', '31', '32'], ['31', '32', '33'], ['32', '33', '34'],
                ['35', '36', '37'], ['36', '37', '38'], ['37', '38', '39'],
                ['40', '41', '42'], ['41', '42', '43'], ['42', '43', '44'],
                ['45', '46', '47'], ['46', '47', '48'], ['47', '48', '49'],
                ['50', '51', '52'], ['51', '52', '53'], ['52', '53', '54'],
                ['55', '56', '57'], ['56', '57', '58'], ['57', '58', '59'],
                ['60', '61', '62'], ['61', '62', '63'], ['62', '63', '64'],
                ['65', '66', '67'], ['66', '67', '68'], ['67', '68', '69'],
                ['70', '71', '72'], ['71', '72', '73'], ['72', '73', '74']]

    def grade_vazia(self):
        pass
        '''
        lista = [['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', '']]
        '''
        lista = [['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', '']]
        return lista

    def dias_semana(self):
        pass
        '''
        lista_ds = [['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
                    ['11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21'],
                    ['22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32'],
                    ['33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43'],
                    ['44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54']]
        return lista_ds
        '''
        lista_ds = [['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14'],
                    ['15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29'],
                    ['30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44'],
                    ['45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59'],
                    ['60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74']]
        return lista_ds

    def cabecalho(self):
        return ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta']

    def converte_slot_lc(self, slot):
        pass
        '''
        lista_lc = [[0, 0], [1, 0], [2, 0], [3,0], [4, 0], [6, 0],[7, 0], [8, 0], [9, 0], [10,0], [12, 0],
                    [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [6, 1], [7, 1], [8, 1], [9, 1], [10, 1], [12, 1],
                    [0, 2], [1, 2], [2, 2], [3, 2], [4, 2], [6, 2], [7, 2], [8, 2], [9, 2], [10, 2], [12, 2],
                    [0, 3], [1, 3], [2, 3], [3, 3], [4, 3], [6, 3], [7, 3], [8, 3], [9, 3], [10, 3], [12, 3],
                    [0, 4], [1, 4], [2, 4], [3, 4], [4, 4], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [12, 4]]
        return lista_lc[slot][0], lista_lc[slot][1]
        '''
        lista_lc = [[0, 0], [1, 0], [2, 0], [3,0], [4, 0], [6, 0],[7, 0], [8, 0], [9, 0], [10,0], [12, 0], [13, 0],
                    [14, 0], [15, 0], [16, 0],
                    [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [6, 1], [7, 1], [8, 1], [9, 1], [10, 1], [12, 1], [13, 1],
                    [14, 1], [15, 1], [16, 1],
                    [0, 2], [1, 2], [2, 2], [3, 2], [4, 2], [6, 2], [7, 2], [8, 2], [9, 2], [10, 2], [12, 2], [13, 2],
                    [14, 2], [15, 2], [16, 2],
                    [0, 3], [1, 3], [2, 3], [3, 3], [4, 3], [6, 3], [7, 3], [8, 3], [9, 3], [10, 3], [12, 3], [13, 3],
                    [14, 3], [15, 3], [16, 3],
                    [0, 4], [1, 4], [2, 4], [3, 4], [4, 4], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [12, 4], [13, 4],
                    [14, 4], [15, 4], [16, 4]]
        return lista_lc[slot][0], lista_lc[slot][1]

class Slot:
    def __init__(self, slot):
        self._slot = slot

    @property
    def slot(self):
        return self._slot

    @slot.setter
    def slot(self, slot_novo):
        self.slot = slot_novo


class GrupoDisciplinas:
    def __init__(self, tipo_grupo, disciplinas):
        self.tipo_grupo = tipo_grupo
        self.disciplinas = disciplinas


# leitura dataframe escola e criação dos objetos correspondentes:
turmas_objetos = []
disciplinas_objetos = []
professores_objetos = []
slots_objetos = []

turmas_ponteiro = 0
disciplinas_ponteiro = 0
professores_ponteiro = 0
slots_ponteiro = 0
estrela_chaves = []

turma_prov = []
disciplina_prov = []
professor_prov = []
slot_prov = []

controle = []

for index, row in df.iterrows():
    # print(row)
    if row['Código da disc. '] != '611' and row['Código da disc. '] != '1344':
        controle.clear()
        turma_prov.clear()
        disciplina_prov.clear()
        professor_prov.clear()

        turma_prov = [row['Matriz curricular'],
                      row['Etapa (séries)'],
                      row['Número da turma'],
                      row['Tipo de turma (prov. não usaremos)'],
                      row['Cod. Turno'],
                      row['Turno'],
                      row['Código da área de ensino'],
                      row['Área de ensino'], '1']
        disciplina_prov = [row['Matriz curricular'],
                           row['Etapa (séries)'],
                           row['Número da turma'],
                           row['Código da disc. '],
                           row['Nome da disc. '],
                           row['Qtd de aulas na semana'],
                           row['Código da área de ensino'],
                           row['Área de ensino']]
        professor_prov = [row['Identificador do prof. '],
                          row['CPF'],
                          row['Nome']]
        grade = Grade('1', turma_prov[5])
        slot_prov = grade.grade_elementos()

        in_turma = False
        indice = 0
        if len(turmas_objetos) > 0:
            for objeto in turmas_objetos:
                if turma_prov[2] == objeto.numero_turma and\
                    turma_prov[1] == objeto.etapa_serie and\
                    turma_prov[4] == objeto.codigo_turno and\
                    turma_prov[6] == objeto.codigo_area_ensino:
                        in_turma = True
                        break
                indice = indice + 1
        if in_turma:
            controle.append(indice)
        else:
            controle.append(turmas_ponteiro)
            turmas_objetos.append(Turma(turma_prov[0], turma_prov[1], turma_prov[2],
                                        turma_prov[3], turma_prov[4], turma_prov[5],
                                        turma_prov[6], turma_prov[7], turma_prov[8]))
            turmas_ponteiro = turmas_ponteiro + 1

        in_disciplina = False
        indice = 0
        if len(disciplinas_objetos) > 0:
            for objeto in disciplinas_objetos:
                if disciplina_prov[3] == objeto.codigo_disciplina \
                        and disciplina_prov[6] == objeto.codigo_area_ensino \
                        and disciplina_prov[1] == objeto.etapa_serie \
                        and disciplina_prov[0] == objeto.matriz_curricular:
                    in_disciplina = True
                    break
                indice = indice + 1
        if in_disciplina:
            controle.append(indice)
        else:
            controle.append(disciplinas_ponteiro)
            disciplinas_objetos.append(Disciplina(disciplina_prov[0], disciplina_prov[1], disciplina_prov[2],
                                                  disciplina_prov[3], disciplina_prov[4], disciplina_prov[5],
                                                  disciplina_prov[6], turma_prov[7]))
            disciplinas_ponteiro = disciplinas_ponteiro + 1

        in_professor = False
        indice = 0
        if len(professores_objetos) > 0:
            for objeto in professores_objetos:
                if professor_prov[1] == objeto.cpf_professor:
                    in_professor = True
                    break
                indice = indice + 1
        if in_professor:
            controle.append(indice)
        else:
            controle.append(professores_ponteiro)
            professores_objetos.append(Professor(professor_prov[0], professor_prov[1], professor_prov[2]))
            professores_ponteiro = professores_ponteiro + 1

        # # print('slot_prov: ', slot_prov)
        for slots in slot_prov:
            in_slot = False
            indice = 0
            if len(slots_objetos) > 0:
                for objeto in slots_objetos:
                    if slots == objeto.slot:
                        in_slot = True
                        break
                    indice = indice + 1
            if in_slot:
                # controle.append(indice)
                # print('indice: ', indice)
                lista = [controle[0], controle[1], controle[2], indice]
                if lista not in estrela_chaves:
                    estrela_chaves.append(lista)
            else:
                # controle.append(slots_ponteiro)
                # print('slots_ponteiro: ', slots_ponteiro)
                lista = [controle[0], controle[1], controle[2], slots_ponteiro]
                if lista not in estrela_chaves:
                    # #print('Lista: ', lista)
                    estrela_chaves.append(lista)
                    slots_objetos.append(Slot(slots))
                    slots_ponteiro = slots_ponteiro + 1
# #print(estrela_chaves)
'''
for i in range(len(estrela_chaves)):
    print(turmas_objetos[estrela_chaves[i][0]].numero_turma,
          disciplinas_objetos[estrela_chaves[i][1]].codigo_disciplina,
          professores_objetos[estrela_chaves[i][2]].nome_professor,
          slots_objetos[estrela_chaves[i][3]].slot)
'''
print("Len_estrelas: ", len(estrela_chaves))
print("Turmas_objetos: ", len(turmas_objetos))
print("Disciplinas_objetos: ", len(disciplinas_objetos))
print("Professores_objetos: ", len(professores_objetos))
print("Slots_objetos: ", len(slots_objetos))
for i in range(len(estrela_chaves)):
    if turmas_objetos[estrela_chaves[i][0]].numero_turma == '15-1':
        print(disciplinas_objetos[estrela_chaves[i][1]].codigo_disciplina,
              disciplinas_objetos[estrela_chaves[i][1]].nome_disciplina,
              disciplinas_objetos[estrela_chaves[i][1]].quantidade_aulas_semanais)
# [18/01/2023]
# Nesta parte do programa serão introduzidas as regras referentes à pesquisa operacional.
# 1) Variáveis do problema de Timetabling.
#
#      As listas "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos" são compostas
#      por objetos exclusivos, o que significa que, por exemplo, "turmas_objetos" possui todas as turmas da escola
#      que está sendo considerada.
#      Já a lista "estrela_chaves" possui todas as combinações possíveis para os elementos das listas
#      "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos". A estas combinações
#      serão consideradas variáveis para a esolução do problema.
#      Considerar X[t, d, p, s] como sendo a variável de interesse.

# Em uma avaliação preliminar do arquivo que temos em mãos, existem 7.525 combinações válidas t, d, p, s.
# T: 41 turmas
# D: 26 disciplinas
# P: 52 professores
# S: 50 slots

model = gp.Model("Timetabling")
# Variáveis da Pesquisa Operacional:
x_tdps = [i for i in range(len(estrela_chaves))]
x = model.addVars(x_tdps, vtype=gp.GRB.BINARY)
# Criação das variáveis Y:
pj = []  # tuplas professor-janela [p, s]
cont_pj = 0
buffer_s = []  # tdps associado a cada slot
s0 = []
s1 = []
s2 = []
somas = []
for i in range(len(slots_objetos)):
    buffer_s.append([])
for i in range(len(estrela_chaves)):
    estrela_chaves[i].append(i)
    buffer_s[estrela_chaves[i][3]].append(estrela_chaves[i])
grade = Grade('1', 'Matutino')
janelas = grade.janelas()
cont_ypj = 0
for professor in range(len(professores_objetos)):
    # print("Teste - janelas: ", janelas)
    for jan in janelas:  # tuplas (s0, s1, s2)
        # print("Teste - jan in janelas: ", jan)
        for fake in range(1):
            obj_existe = False
            for indice in range(len(slots_objetos)):
                if jan[0] == slots_objetos[indice].slot:
                    pos_s0 = indice
                    obj_existe = True
                    break
            if not obj_existe:
                break

            obj_existe = False
            for indice in range(len(slots_objetos)):
                if jan[1] == slots_objetos[indice].slot:
                    pos_s1 = indice
                    obj_existe = True
                    break
            if not obj_existe:
                break

            obj_existe = False
            for indice in range(len(slots_objetos)):
                if jan[2] == slots_objetos[indice].slot:
                    pos_s2 = indice
                    obj_existe = True
                    break
            if not obj_existe:
                break

            s0.clear()
            s1.clear()
            s2.clear()
            s0_existe = False
            s1_existe = False
            s2_existe = False
            # print('buffer_s[0]: ', buffer_s[0])
            for i in range(len(buffer_s[pos_s0])):
                if professor == buffer_s[pos_s0][i][2]:
                    s0.append(buffer_s[pos_s0][i][4])
                    s0_existe = True
            for i in range(len(buffer_s[pos_s1])):
                if professor == buffer_s[pos_s1][i][2]:
                    s1.append(buffer_s[pos_s1][i][4])
                    s1_existe = True
            for i in range(len(buffer_s[pos_s2])):
                if professor == buffer_s[pos_s2][i][2]:
                    s2.append(buffer_s[pos_s2][i][4])
                    s2_existe = True
            if s0_existe and s1_existe and s2_existe:
                somas.append([copy.deepcopy(s0), copy.deepcopy(s1), copy.deepcopy(s2)])
                pj.append([professor, jan])
                # print('pj: ', pj)
                # print('somas: ', somas)
                # print()
                cont_pj = cont_pj + 1

y_pj = [i for i in range(len(pj))]
y = model.addVars(y_pj, vtype=gp.GRB.BINARY)
tolerancia = 0.0001
# print(somas)
for cont in range(len(somas)):
    # print('somas: ', somas[cont][0])
    # print('somas: ', somas[cont][1])
    # print('somas: ', somas[cont][2])
    # print(x)
    # print(y)
    # print('len(somas[cont][0])): ', len(somas[cont][0]))
    '''
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) + 6 >= (9 * y[cont]==1 +
                                                                                                      tolerancia),
    '''
    eps = 0.0001
    M = 10 + eps    # smallest possible given bounds on x and y

    # Model if x > y, then b = 1, otherwise b = 0
    # m.addConstr(x >= y + eps - M * (1 - b), name="bigM_constr1")
    # print("Teste - RESTRIÇÃO janelas >: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) >= 3 + eps\
                    - M * (1 - y[cont]), name="RESTRIÇÃO janelas >: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))
    # m.addConstr(x <= y + M * b, name="bigM_constr2")

    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) <= 3 + eps\
                    + M * y[cont], name="RESTRIÇÃO janelas <: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))


# --------------------------------------------------------------------------------------------------------
# Função Objetivo da Pesquisa Operacional:
model.setObjective(gp.quicksum(y[i] for i in range(len(y_pj))), sense=gp.GRB.MINIMIZE)
# --------------------------------------------------------------------------------------------------------
# Restrições da Pesquisa Operacional:
inequacoes = []

# RESTRIÇÃO 2:
ts_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][3]] not in ts_lista:
        ts_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][3]])
tdps_lista = []
for ts in ts_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][3]] == ts:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        pass
        print("RESTRIÇÃO 2: t_" + str(ts[0]) + " s_" + str(ts[1]), turmas_objetos[ts[0]].numero_turma, slots_objetos[ts[1]].slot)
        if ("t_" + str(ts[0]) + " s_" + str(ts[1])) == "t_29 s_0" or\
            ("t_" + str(ts[0]) + " s_" + str(ts[1])) == "t_29 s_5" or\
            ("t_" + str(ts[0]) + " s_" + str(ts[1])) == "t_29 s_15" or\
            ("t_" + str(ts[0]) + " s_" + str(ts[1])) == "t_29 s_6" or \
            ("t_" + str(ts[0]) + " s_" + str(ts[1])) == "t_29 s_10" or \
            ("t_" + str(ts[0]) + " s_" + str(ts[1])) == "t_29 s_20":
            pass
        else:
            model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1, "RESTRIÇÃO 2: t_" + str(ts[0]) + " s_" + str(ts[1]))
            inequacoes.append([copy.deepcopy(tdps_lista), 1, '2'])
        '''
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1, "RESTRIÇÃO 2: t_" + str(ts[0]) + " s_" + str(ts[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1, '2'])
        '''
# RESTRIÇÃO 3:
ps_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][2], estrela_chaves[cont][3]] not in ps_lista:
        ps_lista.append([estrela_chaves[cont][2], estrela_chaves[cont][3]])
tdps_lista = []
for ps in ps_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][2], estrela_chaves[cont][3]] == ps:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1,
                        "RESTRIÇÃO 3: p_" + str(ps[0]) + " s_" + str(ps[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1, '3'])

# RESTRIÇÃO 4:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
grade = Grade('1', 'Matutino')
ds_lista = grade.dias_semana()
dias = grade.cabecalho()
'''
for i in range(5):
    lista_um_ds = ds_lista[i]
    for td in td_lista:
        tdps_lista.clear()
        for cont in range(len(estrela_chaves)):
            if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
                if disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais <= 5:
                    if slots_objetos[estrela_chaves[cont][3]].slot in lista_um_ds:
                        tdps_lista.append(cont)
        if len(tdps_lista) > 0:
            model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <=1,
                            "RESTRIÇÃO 4: t_" + str(td[0]) + " d_" + str(td[1]) + " ds_" + dias[i])
            inequacoes.append([copy.deepcopy(tdps_lista), 1, '4'])
'''
for i in range(5):
    lista_um_ds = ds_lista[i]
    for td in td_lista:
        tdps_lista.clear()
        for cont in range(len(estrela_chaves)):
            if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
                resto = disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais % 5
                if resto == 0:
                    razao = int(disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais / 5)
                else:
                    razao = int(disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais / 5) + 1
                if slots_objetos[estrela_chaves[cont][3]].slot in lista_um_ds:
                    tdps_lista.append(cont)
        if len(tdps_lista) > 0:
            model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= razao,
                            "RESTRIÇÃO 4: t_" + str(td[0]) + " d_" + str(td[1]) + " ds_" + dias[i])
            inequacoes.append([copy.deepcopy(tdps_lista), razao, '4'])

# RESTRIÇÃO 6:
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
lista_disc = []
teste = 0
for p in p_lista:
    # print('p: ', p)
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    # print('tdps_lista: ', tdps_lista)
    lista_disc.clear()
    for i in range(len(tdps_lista)):
        if [estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]] not in lista_disc:
            lista_disc.append([estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]])
    soma = 0
    # print('disc: ', lista_disc)
    for i in range(len(lista_disc)):
        soma = soma + disciplinas_objetos[lista_disc[i][1]].quantidade_aulas_semanais
        # print('parcela: ', disciplinas_objetos[lista_disc[i][1]].quantidade_aulas_semanais)
        # print(soma)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) == soma, "RESTRIÇÃO 6: p_" + str(p))
        inequacoes.append([copy.deepcopy(tdps_lista), soma, '6'])


# RESTRIÇÃO 7:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
for td in td_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) == disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]]\
                        .quantidade_aulas_semanais, "RESTRIÇÃO 7: t_" + str(td[0]) + " d_" + str(td[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]]\
                        .quantidade_aulas_semanais, '7'])

# --------------------------------------------------------------------------------------------------------
# Execução da modelagem:
model.optimize()
# print(model.display())

'''
print('x: ', len(x))
print('y: ', len(y))

print(x)
for i in range(len(x)):
    print('x[', i, '] = ', x[i].X)
'''
# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):

arquivo = open("grade completa da escola.txt", "w+")
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    lista_vizinhos = [] # Testes escrita "JANELA"
    for i in range(len(tdps_lista)):
        if x[tdps_lista[i]].X == 1:
        # if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            lista_vizinhos.append(slot_da_vez)  # Testes escrita "JANELA"
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "Turma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma)\
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)\
                + "\n" + "C: " + x[tdps_lista[i]].varName
            nova_grade[l][c] = info

    janelas_ref = grade.janelas()    # Testes escrita "JANELA"
    for i in range(len(slots_objetos)):
        slot_da_vez = int(slots_objetos[i].slot)
        for j in range(len(janelas_ref)):
            if slot_da_vez not in lista_vizinhos and int(janelas_ref[j][1]) == slot_da_vez:
                vizinho1 = int(janelas_ref[j][0])
                vizinho2 = int(janelas_ref[j][2])
                if vizinho1 in lista_vizinhos and vizinho2 in lista_vizinhos:
                    l, c = grade.converte_slot_lc(slot_da_vez)
                    info = nova_grade[l][c]
                    if info != "":
                        print("Algo errado.")
                        sys.exit(0)
                    else:
                        info = info + "** JANELA **"
                        nova_grade[l][c] = info

    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('', file = arquivo)
    print('', file = arquivo)
    mostrar_nome_completo = False
    if mostrar_nome_completo:
        print('Professor(a): ', professores_objetos[p].nome_professor)
        print('Professor(a): ', professores_objetos[p].nome_professor, file = arquivo)
    else:
        nome_completo = professores_objetos[p].nome_professor.split()
        abreviacao = ''
        for i in range(len(nome_completo)):
            abreviacao = abreviacao + nome_completo[i][0]
        print('Professor(a): ', abreviacao)
        print(apresentacao)
        print('Professor(a): ', abreviacao, file = arquivo)
        print(apresentacao, file = arquivo)
t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        if x[tdps_lista[i]].X == 1:
        # if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            if mostrar_nome_completo:
                info = info + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                        + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                        + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            else:
                nome_completo = professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor.split()
                abreviacao = ''
                for j in range(len(nome_completo)):
                    abreviacao = abreviacao + nome_completo[j][0]
                info = info + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina \
                       + "\n" + "Professor(a): " + abreviacao\
                       + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma:  ', turmas_objetos[t].numero_turma, "Área de Ensino: ", turmas_objetos[t].area_ensino)
    print(apresentacao)
    print('', file = arquivo)
    print('', file = arquivo)
    print('Turma:  ', turmas_objetos[t].numero_turma, "Área de Ensino: ", turmas_objetos[t].area_ensino, file = arquivo)
    print(apresentacao, file = arquivo)
    cont = 0
    print('len(x): ', len(x))
    for i in range(len(x)):
        if x[i].X == 1:
            cont = cont + 1
    print('Total de X: ', cont)
    print('len(y): ', len(y))
    cont = 0
    for i in range(len(y)):
        if y[i].X == 1:
            cont = cont + 1
    print('Total de Y: ', cont)

# --------------------------------------------------------------------------------------------------------

# Recorrência se resultado for Unfeasible:

# model.write("model.ilp")

# From "https://www.gurobi.com/documentation/10.0/examples/workforce2_py.html#subsubsection:workforce2.py":
status = model.Status
if status == gp.GRB.UNBOUNDED:
    print('The model cannot be solved because it is unbounded')
    sys.exit(0)
if status == gp.GRB.OPTIMAL:
    print('The optimal objective is %g' % model.ObjVal)
    sys.exit(0)
if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
    print('Optimization was stopped with status %d' % status)
    sys.exit(0)

# do IIS
print('The model is infeasible; computing IIS')
removed = []

# Loop until we reduce to a model that can be solved
while True:

    model.computeIIS()
    print('\nThe following constraint cannot be satisfied:')
    for c in model.getConstrs():
        if c.IISConstr:
            print('%s' % c.ConstrName)
            # Remove a single constraint from the model
            removed.append(str(c.ConstrName))
            model.remove(c)
            break
    print('')

    model.optimize()
    status = model.Status

    if status == gp.GRB.UNBOUNDED:
        print('The model cannot be solved because it is unbounded')
        sys.exit(0)
    if status == gp.GRB.OPTIMAL:
        break
    if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
        print('Optimization was stopped with status %d' % status)
        sys.exit(0)

print('\nThe following constraints were removed to get a feasible LP:')
print(removed)
sys.exit(0)

# --------------------------------------------------------------------------------------------------------
# Neste ponto a estrutura de dados referente às inequações será transformada de lista para dicionário:
'''
dict = {}
for i in range(len(inequacoes)):
    for j in range(len(inequacoes[i][0])):
        # print("inequação: ", inequacoes[i])
        if inequacoes[i][0][j] not in dict:
            dict[inequacoes[i][0][j]] = [i]
            # print("dict: ", "[", inequacoes[i][0][j], "]", dict[inequacoes[i][0][j]])
        else:
            dado = dict[inequacoes[i][0][j]]
            dado.append(i)
            dict[inequacoes[i][0][j]] = dado
            # print("dict: ", "[", inequacoes[i][0][j], "]", dict[inequacoes[i][0][j]])
'''
# --------------------------------------------------------------------------------------------------------
lista_tdps = []
lista_d = []
lista_p = []
lista_s = []
for t in range(len(turmas_objetos)):
    for d in range(len(disciplinas_objetos)):
        for p in range(len(professores_objetos)):
            for s in range(len(slots_objetos)):
                lista_s.append(99999)
            lista_p.append(lista_s)
            lista_s = []
        lista_d.append(lista_p)
        lista_p = []
    lista_tdps.append(lista_d)
    lista_d = []
for i in range(len(estrela_chaves)):
    lista_tdps[estrela_chaves[i][0]][estrela_chaves[i][1]][estrela_chaves[i][2]][estrela_chaves[i][3]] = i
# --------------------------------------------------------------------------------------------------------
class Individuo:
    def __init__(self, individuo):
        self.individuo = individuo
        self.solucao = []
        self.slot_problema = 0
        self.inequacoes = []
        self.lista_tdps = []
        self.dict = {}

    def individuo(self):
        return self.individuo

    def slot_problema(self):
        return self.slot_problema

    '''
    def testa_solucao(self, inequacoes, lista_tdps, dict):
        # print('\nTestando solução')
        inequacoes_copia = copy.deepcopy(inequacoes)
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                # print('valor da vez: ', valor_da_vez)
                tem_7 = False
                tem_6 = False
                tem_4 = False
                tem_3 = False
                tem_2 = False
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '2':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            tem_2 = True
                            # print('tem_2 True')
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '3':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            tem_3 = True
                            # print('tem_3 True')
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '4':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            tem_4 = True
                            # print('tem_4 True')
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '6':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            tem_6 = True
                            # print('tem_6 True')
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '7':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            tem_7 = True
                            # print('tem_7 True')
                            break
                # print('valor_da_vez: ', valor_da_vez, tem_2, tem_3, tem_4, tem_6, tem_7)
                if tem_2 and tem_3 and tem_4 and tem_6 and tem_7:
                    # limpar inequações
                    for i in range(len(inequacoes_copia)):
                        if inequacoes_copia[i][1] > 0 and valor_da_vez in inequacoes_copia[i][0]:
                            inequacoes_copia[i][1] = inequacoes_copia[i][1] - 1
                else:
                    return False
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                self.solucao.append(valor_da_vez)
        return True
        '''
    '''
    def testa_solucao(self, inequacoes, lista_tdps, dict):
        inequacoes_copia = copy.deepcopy(inequacoes)
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                lista_ponteiros = dict[valor_da_vez]
                # print('valor da vez: ', valor_da_vez)
                tem_7 = False
                tem_6 = False
                tem_4 = False
                tem_3 = False
                tem_2 = False
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '2':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            tem_2 = True
                            # print('tem_2 True')
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '3':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            tem_3 = True
                            # print('tem_3 True')
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '4':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            tem_4 = True
                            # print('tem_4 True')
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '6':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            tem_6 = True
                            # print('tem_6 True')
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '7':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            tem_7 = True
                            # print('tem_7 True')
                            break
                # print('valor_da_vez: ', valor_da_vez, tem_2, tem_3, tem_4, tem_6, tem_7)
                if tem_2 and tem_3 and tem_4 and tem_6 and tem_7:
                    # limpar inequações
                    for ponteiro in lista_ponteiros:
                        if inequacoes_copia[ponteiro][1] > 0 and valor_da_vez in inequacoes_copia[ponteiro][0]:
                            inequacoes_copia[ponteiro][1] = inequacoes_copia[ponteiro][1] - 1
                else:
                    return False
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                self.solucao.append(valor_da_vez)
        return True
        '''

    def testa_solucao(self, inequacoes, lista_tdps, dict_ponteiros):
        t70 = time.time()
        # inequacoes_copia = copy.deepcopy(inequacoes)
        dict_inequacoes = {}    # valor [1] associado à inequação apontada pelo ponteiro da vez
        for i in range(len(inequacoes)):
            dict_inequacoes[i] = inequacoes[i][1]
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno.upper() == 'MATUTINO':   #if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                lista_ponteiros = dict_ponteiros[valor_da_vez]
                # print('valor da vez: ', valor_da_vez)
                tem_7 = False
                tem_6 = False
                tem_4 = False
                tem_3 = False
                tem_2 = False
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '2':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_2 = True
                            # print('tem_2 True')
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '3':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_3 = True
                            # print('tem_3 True')
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '4':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_4 = True
                            # print('tem_4 True')
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '6':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_6 = True
                            # print('tem_6 True')
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '7':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            tem_7 = True
                            # print('tem_7 True')
                            break
                # print('valor_da_vez: ', valor_da_vez, tem_2, tem_3, tem_4, tem_6, tem_7)
                if tem_2 and tem_3 and tem_4 and tem_6 and tem_7:
                    # limpar inequações
                    for ponteiro in lista_ponteiros:
                        if dict_inequacoes[ponteiro] > 0 and valor_da_vez in inequacoes[ponteiro][0]:
                            dict_inequacoes[ponteiro] = dict_inequacoes[ponteiro] - 1
                else:
                    t71 = time.time()
                    # print("t_dentro_solucao_False: ", t71 - t70)
                    dict_inequacoes.clear()
                    return False
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno.upper() == 'MATUTINO':   #if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                self.solucao.append(valor_da_vez)
        t71 = time.time()
        # print("t_dentro_solucao_True: ", t71 - t70)
        dict_inequacoes.clear()
        return True

    def solucao_frame(self):
        return self.solucao

    '''
    def fitness(self, inequacoes, lista_tdps, dict):
        inequacoes_copia = copy.deepcopy(inequacoes)
        fitness = 0
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                delta = 0
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '2':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print('fitness2: ', fitness)
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '3':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print('fitness3: ', fitness)
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '4':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print('fitness4: ', fitness)
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '6':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print('fitness6: ', fitness)
                            break
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '7':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print('fitness7: ', fitness)
                            break
                if delta < 5:
                    self.slot_problema = f # possível slot com problema
                # print()
                # limpar inequações
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and valor_da_vez in inequacoes_copia[i][0]:
                        inequacoes_copia[i][1] = inequacoes_copia[i][1] - 1
        return fitness
    '''
    '''
    def fitness(self, inequacoes, lista_tdps, dict):
        inequacoes_copia = copy.deepcopy(inequacoes)
        fitness = 0
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                lista_ponteiros = dict[valor_da_vez]
                # print("lista_indices: ", lista_indices)
                delta = 0
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '2':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print('fitness2: ', fitness)
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '3':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness3: ', fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '4':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness4: ', fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '6':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness6: ', fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and inequacoes_copia[ponteiro][2] == '7':
                        if valor_da_vez in inequacoes_copia[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness7: ', fitness)
                            break
                if delta < 5:
                    self.slot_problema = f # possível slot com problema
                # print()
                # limpar inequações
                for ponteiro in lista_ponteiros:
                    if inequacoes_copia[ponteiro][1] > 0 and valor_da_vez in inequacoes_copia[ponteiro][0]:
                        inequacoes_copia[ponteiro][1] = inequacoes_copia[ponteiro][1] - 1
        return fitness
        '''

    def fitness(self, inequacoes, lista_tdps, dict_ponteiros):
        t70 = time.time()
        # inequacoes_copia = copy.deepcopy(inequacoes)
        fitness = 0
        dict_inequacoes = {}    # valor [1] associado à inequação apontada pelo ponteiro da vez
        for i in range(len(inequacoes)):
            dict_inequacoes[i] = inequacoes[i][1]
        for f in range(frame_tamanho):
            if self.individuo[f] != 0:
                t = self.individuo[f][0]
                d = self.individuo[f][1]
                p = self.individuo[f][2]
                if turmas_objetos[t].turno.upper() == 'MATUTINO':   #if turmas_objetos[t].turno == 'Matutino':
                    s = f
                else:
                    s = f + 25
                valor_da_vez = lista_tdps[t][d][p][s]
                lista_ponteiros = dict_ponteiros[valor_da_vez]
                # print("lista_indices: ", lista_indices)
                delta = 0
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '2':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print('fitness2: ', fitness)
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '3':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness3: ', fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '4':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness4: ', fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '6':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness6: ', fitness)
                            break
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and inequacoes[ponteiro][2] == '7':
                        if valor_da_vez in inequacoes[ponteiro][0]:
                            fitness = fitness + 1
                            delta = delta + 1
                            # print("valor_da_vez: ", valor_da_vez, "lista_indices: ", lista_indices, "inequacoes: ", inequacoes[i], "fitness: ",fitness)
                            # print('fitness7: ', fitness)
                            break
                if delta < 5:
                    self.slot_problema = f # possível slot com problema
                # print()
                # limpar inequações
                for ponteiro in lista_ponteiros:
                    if dict_inequacoes[ponteiro] > 0 and valor_da_vez in inequacoes[ponteiro][0]:
                        dict_inequacoes[ponteiro] = dict_inequacoes[ponteiro] - 1
        t71 = time.time()
        # print("t_dentro_fitness_unico: ", t71 - t70)
        dict_inequacoes.clear()
        return fitness
# --------------------------------------------------------------------------------------------------------
testa = 2
# Testes de heurística:
# #1: Estratégia = Encaixando peças
# Aqui neste bloco será aplicado um algoritmo genético, mas sem a restrição de janelas.
if testa == 1:
    iteracoes = 0
    tempo_1 = time.time()
    turmas_backup = []
    turmas_creditos = []

    n_individuos = 50
    range_n = []
    for i in range(n_individuos):
        range_n.append(i)

    range_25 = []
    frame_tamanho = 25
    for i in range(frame_tamanho):
        range_25.append(i)

    range_0_25 = []
    frame_tamanho = 25
    for i in range(frame_tamanho + 1):
        range_0_25.append(i)

    range_100 = []
    for i in range(1, 101):
        range_100.append(i)

    range_10000 = []
    for i in range(0, 10001):
        range_10000.append(i)

    for i in range(len(turmas_objetos)):
        # N_individuos representa o número de indivíduos deste algoritmo genético
        frame_turno = ''
        frame_tuplas_tdp = []
        cred = 0
        for j in range(len(estrela_chaves)):
            tu = estrela_chaves[j][0]
            if tu == i:
                di = estrela_chaves[j][1]
                pr = estrela_chaves[j][2]
                if [tu, di, pr] not in frame_tuplas_tdp:
                    cr = disciplinas_objetos[di].quantidade_aulas_semanais
                    cred = cred + cr
                    for w in range(cr):
                        frame_tuplas_tdp.append([tu, di, pr])
        if len(frame_tuplas_tdp) < frame_tamanho:
            falta = frame_tamanho - len(frame_tuplas_tdp)
            for k in range(falta):
                frame_tuplas_tdp.append(0)
        turmas_backup.append(frame_tuplas_tdp)
        turmas_creditos.append(cred)
    lista_sorteados = []
    for t in range(len(turmas_objetos)):
        individuos = []  # n indivíduos (cada indivíduo, um frame)
        print('\nTurma: ', t)
        vez = 1
        # print('Vez: ', vez)
        temp_sorteados = []
        temp_entradas = copy.deepcopy(turmas_backup[t])
        # temp_inequacoes = copy.deepcopy(inequacoes)   $$

        # melhorando performance    $$
        temp_index = []
        for i in range(len(turmas_backup[t])):
            if turmas_backup[t][i] != 0:
                tt = turmas_backup[t][i][0]
                dd = turmas_backup[t][i][1]
                pp = turmas_backup[t][i][2]
                for ss in range(25):
                    if turmas_objetos[tt].turno.upper() == 'MATUTINO':  #if turmas_objetos[tt].turno == 'Matutino':
                        valor = lista_tdps[tt][dd][pp][ss]
                        if valor not in temp_index:
                            temp_index.append(valor)
                    else:
                        zz = ss + 25
                        valor = lista_tdps[tt][dd][pp][zz]
                        if valor not in temp_index:
                            temp_index.append(valor)
        temp_inequacoes100 = []
        for i in range(len(temp_index)):
            for j in range(len(inequacoes)):
                if temp_index[i] in inequacoes[j][0]:
                    diferentes = True
                    for k in range(len(temp_inequacoes100)):
                        if inequacoes[j][0] == temp_inequacoes100[k][0] and\
                            inequacoes[j][1] == temp_inequacoes100[k][1] and \
                            inequacoes[j][2] == temp_inequacoes100[k][2]:
                            diferentes = False
                            break
                    if diferentes:
                        temp_inequacoes100.append(inequacoes[j])
        temp_inequacoes = copy.deepcopy(temp_inequacoes100)

        print('Tamanho entrada: ', turmas_creditos[t])
        max_fit = 5 * turmas_creditos[t]
        print('max_fit: ', max_fit)
        populacao_atual = []
        temp = copy.deepcopy(turmas_backup[t])
        for i in range(n_individuos):
            shuffle(temp)
            populacao_atual.append(Individuo(copy.deepcopy(temp)))
        # populações convergem aqui.
        finalizado = False
        while not finalizado:
            individuo_fitness = []
            for i in range(len(populacao_atual)):
                individuo_fitness.append(populacao_atual[i].fitness(temp_inequacoes, lista_tdps))
            # Vamos isolar os 2 melhores da população, mantendo-os na população nova.
            print(vez, 'Turma: ', t, 'indivíduo_fitness: ', individuo_fitness)

            # Aqui começa a tentativa de se implementar o que estou chamando de engenharia genética ou
            # manipulação genética.
            # Populações com fitness = máximo - 1 devem ser analisadas separadamente, no sentido de se
            # finalizar a busca por solução.
            top_quantidade = 8
            for i in range(len(populacao_atual)):
                if i >= top_quantidade:
                    if individuo_fitness[i] == max_fit - 1:
                        # print('Achei um max_fit - 1', 'i: ', i)
                        temp_populacao = copy.deepcopy(populacao_atual[i])
                        temp_populacao.fitness(temp_inequacoes, lista_tdps)    # para descobrir qual o slot com problema
                        slotcomproblema = temp_populacao.slot_problema
                        # print('slotcomproblema: ', slotcomproblema)
                        # print('populacao_atual[i]: ', temp_populacao.individuo)
                        for j in range(25):
                            if j != slotcomproblema:
                                temp_list = copy.deepcopy(temp_populacao.individuo)
                                temp_slot = temp_list[j]
                                temp_list[j] = temp_list[slotcomproblema]
                                temp_list[slotcomproblema] = temp_slot
                                # print('        temp_list: ', temp_list)
                                nova_populacao = Individuo(temp_list)
                                if nova_populacao.fitness(temp_inequacoes, lista_tdps) == max_fit:
                                    print('Encontrei solução através de manipulação genética.')
                                    populacao_atual[i] = copy.deepcopy(nova_populacao)
                                    individuo_fitness[i] = max_fit
                                    break
                        # print('Turma:_', t, 'indivíduo_fitness: ', individuo_fitness)
            temp_top = []
            grupo_melhores_fitnesses = []
            top = []
            for i in range(len(individuo_fitness)):
                if individuo_fitness[i] not in grupo_melhores_fitnesses:
                    grupo_melhores_fitnesses.append(individuo_fitness[i])
            grupo_melhores_fitnesses.sort()
            grupo_melhores_fitnesses.reverse()
            # print('grupo_melhores_fitnesses: ', grupo_melhores_fitnesses)
            for i in range(len(grupo_melhores_fitnesses)):
                for j in range(len(individuo_fitness)):
                    if grupo_melhores_fitnesses[i] == individuo_fitness[j]:
                        temp_top.append(populacao_atual[j])
                if i == 0:
                    shuffle(temp_top)   # para possibilitar que novos melhores possam fazer parte do topo.
            for i in range(top_quantidade):
                top.append(temp_top[0])
                temp_top.pop(0)
            # Expandir o resultado absoluto do fitness para resultado relativo do fitness, tomando
            #       como referência o menor valor [normalização].
            referencia = 500
            for i in range(len(populacao_atual)):
                if individuo_fitness[i] < referencia:
                    referencia = individuo_fitness[i]
            for i in range(len(populacao_atual)):
                individuo_fitness[i] = individuo_fitness[i] - referencia + 1
            # Aqui começa a seleção
            # Para selecionar é preciso transformar o valor de fitness em uma escala de 0-10000.
            total = 0
            for i in range(len(populacao_atual)):
                total = total + individuo_fitness[i]
            # print('individuo_fitness: ', individuo_fitness)
            roleta_range = []
            for i in range(len(populacao_atual)):
                if i == 0:
                    inicio = 0
                else:
                    inicio = roleta_range[i-1][1]
                fim = inicio + (individuo_fitness[i] * 80 / total)
                roleta_range.append([inicio, fim])
            selecionados = []
            for i in range(len(populacao_atual)):
                valor = choice(range_10000)
                for j in range(len(populacao_atual)):
                    if roleta_range[j][0] <= valor and valor <= roleta_range[j][1]:
                        selecionados.append(populacao_atual[j])
            # Neste ponto temos os selecionados.
            lista_crossover = []
            nao_lista_crossover = []
            pc = 90
            for i in range(len(selecionados)):
                valor = choice(range_100)
                if valor <= pc:
                    lista_crossover.append(selecionados[i])
                else:
                    nao_lista_crossover.append(selecionados[i])
            # Verificar se número ímpar de selecionados:
            if len(lista_crossover)%2 == 0:
                pass
            else:
                tamanho_lista = len(lista_crossover)
                indice = tamanho_lista - 1
                valor = lista_crossover[indice]
                nao_lista_crossover.append(valor)
                lista_crossover.pop(indice)
            # Realizar crossover (position-based crossover)
            # Critério: trocar o conteúdo de posições e manter as outras
            # Então vamos sortear as posições que serão embaralhadas
            troca_n = 4
            range_troca = []
            while len(range_troca) != troca_n:
                sorte = choice(range_25)
                if sorte not in range_troca:
                    range_troca.append(sorte)
            # Vamos gerar os filhos.
            '''
            filhos = []
            for i in range(len(lista_crossover)):
                filho = []
                posicao_nova = []
                lista_individuo = lista_crossover[i].individuo
                for j in range(len(range_troca)):
                    posicao_nova.append(lista_individuo[range_troca[j]])
                shuffle(posicao_nova)
                for j in range(frame_tamanho):
                    if j in range_troca:
                        filho.append(posicao_nova[0])
                        posicao_nova.pop(0)
                    else:
                        filho.append(lista_individuo[j])
                filhos.append(filho)
    
            '''
            filhos = []
            for i in range(int(len(lista_crossover) / 2)):
                corte1 = choice(range_25)
                # corte1 = 0
                corte2 = choice(range_25)
                # corte2 = 2
                if corte2 < corte1:
                    temp = corte2
                    corte2 = corte1
                    corte1 = temp
                filho1_copia = []
                pai1_exclusivo = []
                filho2_copia = []
                pai2_exclusivo = []
                if corte1 == corte2:
                    pass
                else:
                    cross0 = lista_crossover[2 * i].individuo
                    # print('cross0: ', cross0)
                    cross1 = lista_crossover[2 * i + 1].individuo
                    # print('cross1: ', cross1)
                    for j in range(frame_tamanho):
                        if j > corte1 and j <= corte2:
                            filho1_copia.append(cross0[j])
                            filho2_copia.append(cross1[j])
                        else:
                            pai1_exclusivo.append(cross0[j])
                            pai2_exclusivo.append(cross1[j])
                    # print('filho1_copia: ', filho1_copia)
                    # print('filho2_copia: ', filho2_copia)
                    # print('pai1_exclusivo: ', pai1_exclusivo)
                    # print('pai2_exclusivo: ', pai2_exclusivo)
                pai1_todo_sequencial = []
                pai2_todo_sequencial = []
                for j in range(corte2 + 1, corte2 + 1 + frame_tamanho):
                    pai1_todo_sequencial.append(cross0[j % frame_tamanho])
                    pai2_todo_sequencial.append(cross1[j % frame_tamanho])
                pai2_resto = []
                for j in range(len(pai2_todo_sequencial)):
                    if pai2_todo_sequencial[j] in pai1_exclusivo:
                        pai2_resto.append(pai2_todo_sequencial[j])
                        pai1_exclusivo.remove(pai2_todo_sequencial[j])
                pai1_resto = [] #
                for j in range(len(pai1_todo_sequencial)):
                    if pai1_todo_sequencial[j] in pai2_exclusivo:
                        pai1_resto.append(pai1_todo_sequencial[j])
                        pai2_exclusivo.remove(pai1_todo_sequencial[j])
                # print('pai1_todo_sequencial: ', pai1_todo_sequencial)
                # print('pai2_todo_sequencial: ', pai2_todo_sequencial)
                # print('pai2_resto: ', pai2_resto)
                # print('len(pai2_resto): ', len(pai2_resto))
                filho1_total = []
                for j in range(frame_tamanho):
                    if corte1 != corte2:
                        if j > corte1 and j <= corte2:
                            filho1_total.append(filho1_copia[0])
                            filho1_copia.pop(0)
                        else:
                            filho1_total.append(pai2_resto[0])
                            pai2_resto.pop(0)
                    else:
                        filho1_total.append(cross0[j])
                filho2_total = []
                for j in range(frame_tamanho):
                    if corte1 != corte2:
                        if j > corte1 and j <= corte2:
                            filho2_total.append(filho2_copia[0])
                            filho2_copia.pop(0)
                        else:
                            filho2_total.append(pai1_resto[0])
                            pai1_resto.pop(0)
                    else:
                        filho2_total.append(cross0[j])
                # print('filho1_total: ', filho1_total)
                filhos.append(filho1_total)
                filhos.append(filho2_total)



                # print(i, 'len(filho[i]: ', len(filho1_total))
                # print(i, 'len(filho[i]: ', len(filho1_total))

            # Realizar mutação (order-based mutation).
            # Varrer posições e aplicar Bernoulli (pm)
            # Se posição for sofrer mutação, sortear outra posição para realizar a troca
            for i in range(len(filhos)):
                for j in range(frame_tamanho):
                    pm = 15
                    valor = choice(range_100)
                    if valor <= pm:
                        temp = filhos[i][j]
                        dest = choice(range_25)
                        filhos[i][j] = filhos[i][dest]
                        filhos[i][dest] = temp
            # Agora junta top, filhos e não escolhidos
            populacao_atual = []
            for i in range(top_quantidade):
                populacao_atual.append(top[i])
            for i in range(len(filhos)):
                populacao_atual.append(Individuo(filhos[i]))
            for i in range(len(nao_lista_crossover)):
                populacao_atual.append(nao_lista_crossover[i])
            populacao_atual.reverse()
            while len(populacao_atual) > n_individuos:
                populacao_atual.pop(0)
            populacao_atual.reverse()
            # Agora é testar se algum indivíduo é resultado válido.
            finalizado = False
            for i in range(len(populacao_atual)):
                tem_solucao = populacao_atual[i].testa_solucao(temp_inequacoes, lista_tdps)
                if tem_solucao:
                    finalizado = True
                    solucao = populacao_atual[i].solucao_frame()
                    break
            if finalizado:
                for i in range(len(solucao)):
                    lista_sorteados.append(solucao[i])
                    for j in range(len(inequacoes)):
                        if inequacoes[j][1] > 0 and solucao[i] in inequacoes[j][0]:
                            inequacoes[j][1] = inequacoes[j][1] - 1
                finalizado = True
                print('Vezes: -----------------------------', vez)
                iteracoes = iteracoes + vez
            else:
                vez = vez + 1
                # print('Turma: ', t, 'vez: ', vez)
                temp_sorteados = []
                temp_entradas = copy.deepcopy(turmas_backup[t])
                # temp_inequacoes = copy.deepcopy(inequacoes)   $$
                temp_inequacoes = copy.deepcopy(temp_inequacoes100)
                finalizado = False

    xx = []
    for i in range(len(x)):
        if i in lista_sorteados:
            xx.append(1)
        else:
            xx.append(0)

    cont = 0
    for i in range(len(x)):
        if x[i].X == 1:
            cont = cont + 1
    print('Total de X: ', cont)

    cont = 0
    for i in range(len(y)):
        if y[i].X == 1:
            cont = cont + 1
    print('Total de Y: ', cont)

    cont = 0
    for i in range(len(xx)):
        if xx[i] == 1:
            cont = cont + 1
    print('Total de xx: ', cont)
    tempo_2 = time.time()
    intervalo = (tempo_2 - tempo_1) / 60
    print(iteracoes, ' iterações.')
    print(intervalo, ' minutos.')

# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# #1: Estratégia = Encaixando peças
# Aqui neste bloco será aplicado um algoritmo genético, com a restrição de janelas.
if testa == 2:
    # Hiperparâmetros:
    n_individuos = 50
    top_quantidade = 8
    pc = 70
    pm = 1
    troca_n = 4
    max_janelas_professor = 2
    primeira_janela = 0
    total_janelas = max_janelas_professor * len(professores_objetos)
    print("Total_janelas: ", total_janelas)
    #-----------------#
    iteracoes = 0
    tempo_1 = time.time()
    # Neste ponto criaremos o buffer dos professores com os seus slots ocupados: [[0, 1, 25, 33], [2,4] ...]
    # No exemplo, professor 0 ocupa slots 0, 1, 25 e 33.
    windows = []
    for i in range(len(professores_objetos)):
        windows.append([])

    turmas_backup = []
    turmas_creditos = []

    # n_individuos = 50
    range_n = []
    for i in range(n_individuos):
        range_n.append(i)

    range_25 = []
    frame_tamanho = 25
    for i in range(frame_tamanho):
        range_25.append(i)

    range_0_25 = []
    frame_tamanho = 25
    for i in range(frame_tamanho + 1):
        range_0_25.append(i)

    range_100 = []
    for i in range(1, 101):
        range_100.append(i)

    range_10000 = []
    for i in range(0, 10001):
        range_10000.append(i)

    for i in range(len(turmas_objetos)):
        # N_individuos representa o número de indivíduos deste algoritmo genético
        frame_turno = ''
        frame_tuplas_tdp = []
        cred = 0
        for j in range(len(estrela_chaves)):
            tu = estrela_chaves[j][0]
            if tu == i:
                di = estrela_chaves[j][1]
                pr = estrela_chaves[j][2]
                if [tu, di, pr] not in frame_tuplas_tdp:
                    cr = disciplinas_objetos[di].quantidade_aulas_semanais
                    cred = cred + cr
                    for w in range(cr):
                        frame_tuplas_tdp.append([tu, di, pr])
        if len(frame_tuplas_tdp) < frame_tamanho:
            falta = frame_tamanho - len(frame_tuplas_tdp)
            for k in range(falta):
                frame_tuplas_tdp.append(0)
        turmas_backup.append(frame_tuplas_tdp)
        turmas_creditos.append(cred)
    lista_sorteados = []
    for t in range(len(turmas_objetos)):
        individuos = []  # n indivíduos (cada indivíduo, um frame)
        print('\nTurma: ', t)
        vez = 1
        # print('Vez: ', vez)
        temp_sorteados = []
        temp_entradas = copy.deepcopy(turmas_backup[t])
        # temp_inequacoes = copy.deepcopy(inequacoes)   $$

        # melhorando performance    $$
        temp_index = []
        for i in range(len(turmas_backup[t])):
            if turmas_backup[t][i] != 0:
                tt = turmas_backup[t][i][0]
                dd = turmas_backup[t][i][1]
                pp = turmas_backup[t][i][2]
                for ss in range(25):
                    if turmas_objetos[tt].turno.upper() == 'MATUTINO':  #if turmas_objetos[tt].turno == 'Matutino':
                        valor = lista_tdps[tt][dd][pp][ss]
                        if valor not in temp_index:
                            temp_index.append(valor)
                    else:
                        zz = ss + 25
                        valor = lista_tdps[tt][dd][pp][zz]
                        if valor not in temp_index:
                            temp_index.append(valor)
        temp_inequacoes100 = []
        for i in range(len(temp_index)):
            for j in range(len(inequacoes)):
                if temp_index[i] in inequacoes[j][0]:
                    diferentes = True
                    for k in range(len(temp_inequacoes100)):
                        if inequacoes[j][0] == temp_inequacoes100[k][0] and\
                            inequacoes[j][1] == temp_inequacoes100[k][1] and \
                            inequacoes[j][2] == temp_inequacoes100[k][2]:
                            diferentes = False
                            break
                    if diferentes:
                        temp_inequacoes100.append(inequacoes[j])
        temp_inequacoes = copy.deepcopy(temp_inequacoes100)

        dict_ponteiros = {}   # ponteiros
        for i in range(len(temp_inequacoes)):
            for j in range(len(temp_inequacoes[i][0])):
                if temp_inequacoes[i][0][j] not in dict_ponteiros:
                    dict_ponteiros[temp_inequacoes[i][0][j]] = [i]
                else:
                    dado = dict_ponteiros[temp_inequacoes[i][0][j]]
                    dado.append(i)
                    dict_ponteiros[temp_inequacoes[i][0][j]] = dado

        print('Tamanho entrada: ', turmas_creditos[t])
        max_fit = 6 * turmas_creditos[t]
        print('max_fit: ', max_fit)
        populacao_atual = []
        temp = copy.deepcopy(turmas_backup[t])
        for i in range(n_individuos):
            for j in range(i + 2):
                shuffle(temp)
            populacao_atual.append(Individuo(copy.deepcopy(temp)))
        # populações convergem aqui.
        finalizado = False
        while not finalizado:
            # Aqui vamos checar se a população atual não tem gêmeos:
            roda_a_roda = []
            for k in range(frame_tamanho):
                roda_a_roda.append(k)

            for i in range(len(populacao_atual)):
                for j in range(i+1, len(populacao_atual)):
                    if i != j:
                        ind1 = copy.deepcopy(populacao_atual[i].individuo)
                        ind2 = copy.deepcopy(populacao_atual[j].individuo)
                        if ind1 != ind2:
                            pass
                        else:   # tem gêmeos / substituir 'j'
                            # print('i: ', i, 'j: ', j)
                            # print('ind1: ', ind1)
                            # print('ind2: ', ind2)
                            escolha = []
                            while len(escolha) != 6:
                                sorteio = choice(roda_a_roda)
                                if sorteio not in escolha:
                                    escolha.append(sorteio)
                            for k in range(3):
                                temp = copy.deepcopy(ind2[escolha[0]])
                                ind2[escolha[0]] = ind2[escolha[1]]
                                ind2[escolha[1]] = temp
                                escolha.pop(0)
                                escolha.pop(0)
                            # print('ind2: ', ind2)
                            populacao_atual[j] = Individuo(copy.deepcopy(ind2))
            individuo_fitness = []
            for i in range(len(populacao_atual)):
                individuo_fitness.append(populacao_atual[i].fitness(temp_inequacoes, lista_tdps, dict_ponteiros))
            # Neste ponto realizamos a inclusão da restrição das janelas no cálculo do fitness.
            windows2 = []
            # limite_fitness_janelas = (t + 1) * 80 // len(turmas_objetos)
            '''
            if t <= 10:  # t começa em ZERO.
                limite_fitness_janelas = 0
            else:
                limite_fitness_janelas = (t - 10) * 11 // ((len(turmas_objetos) - 1) - 10)
            '''
            # comeco = 0
            if t <= primeira_janela:  # t começa em ZERO.
                limite_fitness_janelas = primeira_janela
            else:
                limite_fitness_janelas = (t - primeira_janela) * total_janelas // ((len(turmas_objetos) - 1) - primeira_janela)

            for i in range(len(populacao_atual)):
                windows2 = copy.deepcopy(windows)
                pontos_fitness = turmas_creditos[t]
                for j in range(frame_tamanho):
                    numero_janelas = 0
                    lista = populacao_atual[i].individuo
                    if lista[j] != 0:
                        tt = lista[j][0]
                        p = lista[j][2]
                        if turmas_objetos[tt].turno.upper() == 'MATUTINO':  #if turmas_objetos[tt].turno == 'Matutino':
                            s = j
                        else:
                            s = j + 25
                        ss = slots_objetos[s].slot
                        if ss not in windows2[p]:
                            windows2[p].append(ss)
                            windows2[p].sort()
                        grade = Grade('1', 'Matutino')
                        janelas = grade.janelas()
                        for m in range(len(janelas)):
                            for n in range(len(windows2)):
                                if janelas[m][0] in windows2[n] and janelas[m][1] not in windows2[n] and janelas[m][2]\
                                        in windows2[n]:
                                    numero_janelas = numero_janelas + 1

                if numero_janelas <= limite_fitness_janelas:
                    individuo_fitness[i] = individuo_fitness[i] + pontos_fitness
                '''
                pontos_inversos = 0
                if i == 0:
                    print('limite_fitness_janelas: ', limite_fitness_janelas)
                    print('numero_janelas: ', numero_janelas)
                if numero_janelas <= limite_fitness_janelas:
                    if limite_fitness_janelas == 0:
                        if i == 0:
                            print('1')
                        individuo_fitness[i] = individuo_fitness[i] + pontos_fitness
                    else:
                        pontos_inversos = - pontos_fitness * numero_janelas // limite_fitness_janelas + pontos_fitness
                        individuo_fitness[i] = individuo_fitness[i] + pontos_inversos
                        if i == 0:
                            print('2')
                            print('pontos_inversos: ', pontos_inversos)
                '''

            # Vamos isolar os melhores da população, mantendo-os na população nova.
            print(vez, ' Turma: ', t, 'indivíduo_fitness: ', individuo_fitness)

            # Aqui começa a tentativa de se implementar o que estou chamando de engenharia genética ou
            # manipulação genética.
            # Populações com fitness = máximo - 1 devem ser analisadas separadamente, no sentido de se
            # finalizar a busca por solução.
            # top_quantidade = 8
            for i in range(len(populacao_atual)):
                if i >= top_quantidade:
                    if individuo_fitness[i] == max_fit - 1:
                        # print('Achei um max_fit - 1', 'i: ', i)
                        temp_populacao = copy.deepcopy(populacao_atual[i])
                        temp_populacao.fitness(temp_inequacoes, lista_tdps, dict_ponteiros)    # para descobrir qual o slot com problema
                        slotcomproblema = temp_populacao.slot_problema
                        # print('slotcomproblema: ', slotcomproblema)
                        # print('populacao_atual[i]: ', temp_populacao.individuo)
                        for j in range(25):
                            if j != slotcomproblema:
                                temp_list = copy.deepcopy(temp_populacao.individuo)
                                temp_slot = temp_list[j]
                                temp_list[j] = temp_list[slotcomproblema]
                                temp_list[slotcomproblema] = temp_slot
                                # print('        temp_list: ', temp_list)
                                nova_populacao = Individuo(temp_list)

                                dentro_janelas = False
                                windows2 = copy.deepcopy(windows)
                                pontos_fitness = turmas_creditos[t]
                                for k in range(frame_tamanho):
                                    numero_janelas = 0
                                    if temp_list[k] != 0:
                                        tt = temp_list[k][0]
                                        p = temp_list[k][2]
                                        if turmas_objetos[tt].turno.upper() == 'MATUTINO':  #if turmas_objetos[tt].turno == 'Matutino':
                                            s = k
                                        else:
                                            s = k + 25
                                        ss = slots_objetos[s].slot
                                        if ss not in windows2[p]:
                                            windows2[p].append(ss)
                                            windows2[p].sort()
                                        grade = Grade('1', 'Matutino')
                                        janelas = grade.janelas()
                                        for m in range(len(janelas)):
                                            for n in range(len(windows2)):
                                                if janelas[m][0] in windows2[n] and janelas[m][1] not in windows2[n] and \
                                                        janelas[m][2] \
                                                        in windows2[n]:
                                                    numero_janelas = numero_janelas + 1
                                if numero_janelas <= limite_fitness_janelas:
                                    dentro_janelas = True

                                if dentro_janelas and nova_populacao.fitness(temp_inequacoes, lista_tdps, dict_ponteiros) ==\
                                        max_fit - turmas_creditos[t]:
                                    print('Encontrei solução através de manipulação genética.')
                                    populacao_atual[i] = copy.deepcopy(nova_populacao)
                                    individuo_fitness[i] = max_fit
                                    break
                        # print('Turma:_', t, 'indivíduo_fitness: ', individuo_fitness)
            temp_top = []
            grupo_melhores_fitnesses = []
            top = []
            for i in range(len(individuo_fitness)):
                if individuo_fitness[i] not in grupo_melhores_fitnesses:
                    grupo_melhores_fitnesses.append(individuo_fitness[i])
            grupo_melhores_fitnesses.sort()
            grupo_melhores_fitnesses.reverse()
            # print('grupo_melhores_fitnesses: ', grupo_melhores_fitnesses)
            for i in range(len(grupo_melhores_fitnesses)):
                for j in range(len(individuo_fitness)):
                    if grupo_melhores_fitnesses[i] == individuo_fitness[j]:
                        temp_top.append(populacao_atual[j])
                if i == 0:
                    shuffle(temp_top)   # para possibilitar que novos melhores possam fazer parte do topo.
            for i in range(top_quantidade):
                top.append(temp_top[0])
                temp_top.pop(0)
            # Expandir o resultado absoluto do fitness para resultado relativo do fitness, tomando
            #       como referência o menor valor [normalização].
            referencia = 500
            for i in range(len(populacao_atual)):
                if individuo_fitness[i] < referencia:
                    referencia = individuo_fitness[i]
            '''
            for i in range(len(populacao_atual)):
                individuo_fitness[i] = individuo_fitness[i] - referencia + 1
            '''

            # Aqui começa a seleção
            # Para selecionar é preciso transformar o valor de fitness em uma escala de 0-10000.
            total = 0
            for i in range(len(populacao_atual)):
                total = total + individuo_fitness[i]
            # print('individuo_fitness: ', individuo_fitness)
            roleta_range = []
            for i in range(len(populacao_atual)):
                if i == 0:
                    inicio = 0
                else:
                    inicio = roleta_range[i-1][1]
                fim = inicio + (individuo_fitness[i] * 10000 / total)
                roleta_range.append([inicio, fim])
            selecionados = []
            for i in range(len(populacao_atual)):
                valor = choice(range_10000)
                for j in range(len(populacao_atual)):
                    if roleta_range[j][0] <= valor and valor <= roleta_range[j][1]:
                        selecionados.append(populacao_atual[j])
            # Neste ponto temos os selecionados.
            lista_crossover = []
            nao_lista_crossover = []
            # pc = 70
            for i in range(len(selecionados)):
                valor = choice(range_100)
                if valor <= pc:
                    lista_crossover.append(selecionados[i])
                else:
                    nao_lista_crossover.append(selecionados[i])
            # Verificar se número ímpar de selecionados:
            if len(lista_crossover)%2 == 0:
                pass
            else:
                tamanho_lista = len(lista_crossover)
                indice = tamanho_lista - 1
                valor = lista_crossover[indice]
                nao_lista_crossover.append(valor)
                lista_crossover.pop(indice)
            # Realizar crossover (position-based crossover)
            # Critério: trocar o conteúdo de posições e manter as outras
            # Então vamos sortear as posições que serão embaralhadas
            troca_n = 4
            range_troca = []
            while len(range_troca) != troca_n:
                sorte = choice(range_25)
                if sorte not in range_troca:
                    range_troca.append(sorte)
            # Vamos gerar os filhos.
            '''
            filhos = []
            for i in range(len(lista_crossover)):
                filho = []
                posicao_nova = []
                lista_individuo = lista_crossover[i].individuo
                for j in range(len(range_troca)):
                    posicao_nova.append(lista_individuo[range_troca[j]])
                shuffle(posicao_nova)
                for j in range(frame_tamanho):
                    if j in range_troca:
                        filho.append(posicao_nova[0])
                        posicao_nova.pop(0)
                    else:
                        filho.append(lista_individuo[j])
                filhos.append(filho)
            '''
            filhos = []
            for i in range(int(len(lista_crossover) / 2)):
                iguais = True
                while iguais:
                    corte1 = choice(range_25)
                    # corte1 = 0
                    corte2 = corte1
                    while corte2 == corte1:
                        corte2 = choice(range_25)
                    # corte2 = 2
                    if corte2 < corte1:
                        temp = corte2
                        corte2 = corte1
                        corte1 = temp
                    filho1_copia = []
                    pai1_exclusivo = []
                    filho2_copia = []
                    pai2_exclusivo = []
                    if corte1 == corte2:
                        pass
                    else:
                        cross0 = lista_crossover[2 * i].individuo
                        # print('cross0: ', cross0)
                        cross1 = lista_crossover[2 * i + 1].individuo
                        # print('cross1: ', cross1)
                        for j in range(frame_tamanho):
                            if j > corte1 and j <= corte2:
                                filho1_copia.append(cross0[j])
                                filho2_copia.append(cross1[j])
                            else:
                                pai1_exclusivo.append(cross0[j])
                                pai2_exclusivo.append(cross1[j])
                        # print('filho1_copia: ', filho1_copia)
                        # print('filho2_copia: ', filho2_copia)
                        # print('pai1_exclusivo: ', pai1_exclusivo)
                        # print('pai2_exclusivo: ', pai2_exclusivo)
                    pai1_todo_sequencial = []
                    pai2_todo_sequencial = []
                    '''
                    for j in range(corte2 + 1, corte2 + 1 + frame_tamanho):
                        pai1_todo_sequencial.append(cross0[j % frame_tamanho])
                        pai2_todo_sequencial.append(cross1[j % frame_tamanho])
                    '''
                    '''
                    for j in range(frame_tamanho):
                        pai1_todo_sequencial.append(cross0[j])
                        pai2_todo_sequencial.append(cross1[j])
                    '''

                    if cross0 == cross1:
                        for j in range(corte2 + 1, corte2 + 1 + frame_tamanho):
                            pai1_todo_sequencial.append(cross0[j % frame_tamanho])
                            pai2_todo_sequencial.append(cross1[j % frame_tamanho])
                    else:
                        for j in range(frame_tamanho):
                            pai1_todo_sequencial.append(cross0[j])
                            pai2_todo_sequencial.append(cross1[j])

                    pai2_resto = []
                    for j in range(len(pai2_todo_sequencial)):
                        if pai2_todo_sequencial[j] in pai1_exclusivo:
                            pai2_resto.append(pai2_todo_sequencial[j])
                            pai1_exclusivo.remove(pai2_todo_sequencial[j])
                    pai1_resto = [] #
                    for j in range(len(pai1_todo_sequencial)):
                        if pai1_todo_sequencial[j] in pai2_exclusivo:
                            pai1_resto.append(pai1_todo_sequencial[j])
                            pai2_exclusivo.remove(pai1_todo_sequencial[j])
                    # print('pai1_todo_sequencial: ', pai1_todo_sequencial)
                    # print('pai2_todo_sequencial: ', pai2_todo_sequencial)
                    # print('pai2_resto: ', pai2_resto)
                    # print('len(pai2_resto): ', len(pai2_resto))
                    filho1_total = []
                    for j in range(frame_tamanho):
                        if corte1 != corte2:
                            if j > corte1 and j <= corte2:
                                filho1_total.append(filho1_copia[0])
                                filho1_copia.pop(0)
                            else:
                                filho1_total.append(pai2_resto[0])
                                pai2_resto.pop(0)
                        else:
                            filho1_total.append(cross0[j])
                    filho2_total = []
                    for j in range(frame_tamanho):
                        if corte1 != corte2:
                            if j > corte1 and j <= corte2:
                                filho2_total.append(filho2_copia[0])
                                filho2_copia.pop(0)
                            else:
                                filho2_total.append(pai1_resto[0])
                                pai1_resto.pop(0)
                        else:
                            filho2_total.append(cross0[j])
                    # print('filho1_total: ', filho1_total)
                    if filho1_total != cross0 and filho1_total != cross1 and\
                            filho2_total != cross0 and filho2_total != cross1:
                        iguais = False
                filhos.append(filho1_total)
                filhos.append(filho2_total)
                if filho1_total == cross0:
                    print('Filho 0 igual cross0. ', i, corte1, corte2)
                if filho1_total == cross1:
                    print('Filho 0 igual cross1. ', i, corte1, corte2)
                if filho2_total == cross0:
                    print('Filho 1 igual cross0. ', i, corte1, corte2)
                if filho2_total == cross1:
                    print('Filho 1 igual cross1. ', i, corte1, corte2)
                # print(i, 'len(filho[i]: ', len(filho1_total))
                # print(i, 'len(filho[i]: ', len(filho1_total))
            # Realizar mutação (order-based mutation).
            # Varrer posições e aplicar Bernoulli (pm)
            # Se posição for sofrer mutação, sortear outra posição para realizar a troca

            for i in range(len(filhos)):
                for j in range(frame_tamanho):
                    pm = 1
                    valor = choice(range_100)
                    if valor <= pm:
                        # print('Ocorreu uma mutação.   ----------------------------------   -----------------------', i)
                        temp = filhos[i][j]
                        dest = j
                        while dest == j:
                            dest = choice(range_25)
                        filhos[i][j] = filhos[i][dest]
                        filhos[i][dest] = temp

            # Agora junta top, filhos e não escolhidos
            populacao_atual = []
            for i in range(top_quantidade):
                populacao_atual.append(top[i])
            for i in range(len(filhos)):
                populacao_atual.append(Individuo(filhos[i]))
            for i in range(len(nao_lista_crossover)):
                populacao_atual.append(nao_lista_crossover[i])
            populacao_atual.reverse()
            while len(populacao_atual) > n_individuos:
                populacao_atual.pop(0)
            populacao_atual.reverse()

            # Verifica se resultados até aqui são consistentes:

            for i in range(n_individuos):
                ref_i = []
                ref_i = copy.deepcopy(populacao_atual[i].individuo)
                ref_j = []
                ref_j = copy.deepcopy(temp_entradas)
                while len(ref_i) != 0:
                    if ref_i[0] in ref_j:
                        ref_j.remove(ref_i[0])
                        ref_i.pop(0)
                    else:
                        print('Não são iguais.')
                        sys.exit(0)
            # print('Tudo igual.')

            # Agora é testar se algum indivíduo é resultado válido.
            finalizado = False
            for i in range(len(populacao_atual)):
                dentro_janelas = False
                windows2 = copy.deepcopy(windows)
                pontos_fitness = turmas_creditos[t]
                for j in range(frame_tamanho):
                    numero_janelas = 0
                    lista = populacao_atual[i].individuo
                    if lista[j] != 0:
                        tt = lista[j][0]
                        p = lista[j][2]
                        if turmas_objetos[tt].turno.upper() == 'MATUTINO':  #if turmas_objetos[tt].turno == 'Matutino':
                            s = j
                        else:
                            s = j + 25
                        ss = slots_objetos[s].slot
                        if ss not in windows2[p]:
                            windows2[p].append(ss)
                            windows2[p].sort()
                        grade = Grade('1', 'Matutino')
                        janelas = grade.janelas()
                        for m in range(len(janelas)):
                            for n in range(len(windows2)):
                                if janelas[m][0] in windows2[n] and janelas[m][1] not in windows2[n] and janelas[m][2]\
                                        in windows2[n]:
                                    numero_janelas = numero_janelas + 1
                if numero_janelas <= limite_fitness_janelas:
                    dentro_janelas = True
                tem_solucao = False
                if dentro_janelas:
                    tem_solucao = populacao_atual[i].testa_solucao(temp_inequacoes, lista_tdps, dict_ponteiros)
                if tem_solucao:
                    finalizado = True
                    solucao = populacao_atual[i].solucao_frame()
                    break
            if finalizado:
                for i in range(len(solucao)):
                    lista_sorteados.append(solucao[i])
                    pp = estrela_chaves[solucao[i]][2]
                    ss = slots_objetos[estrela_chaves[solucao[i]][3]].slot
                    if ss not in windows[pp]:
                        windows[pp].append(ss)
                    for j in range(len(inequacoes)):
                        if inequacoes[j][1] > 0 and solucao[i] in inequacoes[j][0]:
                            inequacoes[j][1] = inequacoes[j][1] - 1
                finalizado = True
                print('Gerações nesta turma: -----------------------------', vez)
                iteracoes = iteracoes + vez

                parcial_janelas = 0
                grade_rodada = Grade('1', 'Matutino')
                janelas1 = grade_rodada.janelas()
                for m in range(len(janelas1)):
                    for n in range(len(windows)):
                        if janelas1[m][0] in windows[n] and janelas1[m][1] not in windows[n] and janelas1[m][2] \
                                in windows[n]:
                            parcial_janelas = parcial_janelas + 1
                            # print("janelas_referência: ", janelas1[m], "professor?: ", n, "janelas_realizadas: ", windows[n])
                print('Janelas totais: ', parcial_janelas)
                tempo_2 = time.time()
                intervalo = (tempo_2 - tempo_1) / 60
                print(iteracoes, ' gerações totais.')
                print(intervalo, ' minutos até aqui.')
            else:
                vez = vez + 1
                # print('Turma: ', t, 'vez: ', vez)
                temp_sorteados = []
                temp_entradas = copy.deepcopy(turmas_backup[t])
                # temp_inequacoes = copy.deepcopy(inequacoes)   $$
                temp_inequacoes = copy.deepcopy(temp_inequacoes100)

                dict = {}  # dict_temp_inequacoes
                for i in range(len(temp_inequacoes)):
                    for j in range(len(temp_inequacoes[i][0])):
                        if temp_inequacoes[i][0][j] not in dict:
                            dict[temp_inequacoes[i][0][j]] = [i]
                        else:
                            dado = dict[temp_inequacoes[i][0][j]]
                            dado.append(i)
                            dict[temp_inequacoes[i][0][j]] = dado

                finalizado = False
    for i in range(len(windows)):
        windows[i].sort()
        # print('professor: ', i, 'slots: ', windows[i])
    xx = []
    for i in range(len(x)):
        if i in lista_sorteados:
            xx.append(1)
        else:
            xx.append(0)

    cont = 0
    for i in range(len(x)):
        if x[i].X == 1:
            cont = cont + 1
    print('Total de X: ', cont)

    cont = 0
    for i in range(len(y)):
        if y[i].X == 1:
            cont = cont + 1
    print('Total de Y: ', cont)

    cont = 0
    for i in range(len(xx)):
        if xx[i] == 1:
            cont = cont + 1
    print('Total de xx: ', cont)
    tempo_2 = time.time()
    intervalo = (tempo_2 - tempo_1) / 60
    print(iteracoes, ' gerações finais.')
    print(intervalo, ' minutos.')

# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):
# Para o AG.

p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    lista_vizinhos = [] # Testes escrita "JANELA"
    for i in range(len(tdps_lista)):
        # if x[tdps_lista[i]].X == 1:
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            lista_vizinhos.append(slot_da_vez)  # Testes escrita "JANELA"
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "\n\nTurma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma)\
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info

    janelas_ref = grade.janelas()    # Testes escrita "JANELA"
    for i in range(len(slots_objetos)):
        slot_da_vez = int(slots_objetos[i].slot)
        for j in range(len(janelas_ref)):
            if slot_da_vez not in lista_vizinhos and int(janelas_ref[j][1]) == slot_da_vez:
                vizinho1 = int(janelas_ref[j][0])
                vizinho2 = int(janelas_ref[j][2])
                if vizinho1 in lista_vizinhos and vizinho2 in lista_vizinhos:
                    l, c = grade.converte_slot_lc(slot_da_vez)
                    info = nova_grade[l][c]
                    if info != "":
                        print("Algo errado.")
                        sys.exit(0)
                    else:
                        info = info + "*** JANELA ***"
                        nova_grade[l][c] = info

    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Professor(a) - heurística: ', professores_objetos[p].nome_professor)
    print(apresentacao)

t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        # if x[tdps_lista[i]].X == 1:
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "\n\nDisciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma - heurística: ', turmas_objetos[t].numero_turma)
    print(apresentacao)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
print(lista_sorteados)
sys.exit(0)
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# #2: Estratégia = Tratamento único (todos os elementos simultaneamente)
# Aqui neste bloco será aplicado um algoritmo genético, com todas as restrições.
tempo_1 = time.time()
frame_tamanho = 25

# Criação de todos os elementos que irão permutar.
# Os elementos terão o formato [ [t, d, p], [t, d, p], ..., [t, d, p] ]
frame_tuplas_tdp = []
cred = 0
for i in range(len(estrela_chaves)):
    tu = estrela_chaves[i][0]
    di = estrela_chaves[i][1]
    pr = estrela_chaves[i][2]
    if [tu, di, pr] not in frame_tuplas_tdp:
        cr = disciplinas_objetos[di].quantidade_aulas_semanais
        for w in range(cr):
            frame_tuplas_tdp.append([tu, di, pr])
pontos_fitness = len(frame_tuplas_tdp)
max_fit = 6 * len(frame_tuplas_tdp)
print('len(frame_tuplas_tdp):', len(frame_tuplas_tdp))
for i in range(len(turmas_objetos)):
    cont_aulas = 0
    for j in range(len(frame_tuplas_tdp)):
        if frame_tuplas_tdp[j][0] == i:
            cont_aulas = cont_aulas + 1
    while cont_aulas < frame_tamanho:
        frame_tuplas_tdp.append([i, 999, 999])
        cont_aulas = cont_aulas + 1
print('len(frame_tuplas_tdp):', len(frame_tuplas_tdp))

# Neste ponto criaremos o buffer dos professores com os seus slots ocupados: [[0, 1, 25, 33], [2,4] ...]
# No exemplo, professor 0 ocupa slots 0, 1, 25 e 33.

# Criação de buffers de uso geral
n_individuos = 100
range_n = []
for i in range(n_individuos):
    range_n.append(i)

range_25 = []
for i in range(frame_tamanho):
    range_25.append(i)

range_elementos = []
for i in range(len(frame_tuplas_tdp)):
    range_elementos.append(i)

range_0_25 = []
frame_tamanho = 25
for i in range(frame_tamanho + 1):
    range_0_25.append(i)

range_100 = []
for i in range(1, 101):
    range_100.append(i)

range_10000 = []
for i in range(0, 10001):
    range_10000.append(i)

# Elementos que comporão o resultado
lista_sorteados = []

# Fitness
print('max_fit: ', max_fit)

# Criação da população
populacao_atual = []
temp = copy.deepcopy(frame_tuplas_tdp)
for i in range(n_individuos):
    shuffle(temp)
    populacao_atual.append(Individuo(copy.deepcopy(temp)))

inequacoes3 = []
inequacoes4 = []
for i in range(len(inequacoes)):
    if inequacoes[i][2] == '3':
        inequacoes3.append(inequacoes[i])
    if inequacoes[i][2] == '4':
        inequacoes4.append(inequacoes[i])

dict3 = {}
dict4 = {}

# temp_inequacoes = copy.deepcopy(inequacoes)
vez = 1
# populações convergem aqui.
finalizado = False
while not finalizado:
    individuo_fitness = []
    for i in range(len(populacao_atual)):
        individuo_fitness.append(0)

    posicao_erro = []
    for i in range(n_individuos):
        posicao_erro.append([])

    for ii in range(len(populacao_atual)):
        # individuo_fitness.append(populacao_atual[i].fitness(temp_inequacoes, lista_tdps))
        # inequacoes_copia = copy.deepcopy(inequacoes)

        # inequacoes3_copia = copy.deepcopy(inequacoes3)
        # inequacoes4_copia = copy.deepcopy(inequacoes4)

        dict3.clear()
        for i in range(len(inequacoes3)):
            for j in range(len(inequacoes3[i][0])):
                dict3[inequacoes3[i][0][j]] = copy.deepcopy(inequacoes3[i])
        dict4.clear()
        for i in range(len(inequacoes4)):
            for j in range(len(inequacoes4[i][0])):
                dict4[inequacoes4[i][0][j]] = copy.deepcopy(inequacoes4[i])
        '''
        cont = 0
        for i in range(6750):
            valor = dict4[i]
            if i in valor[0]:
                print('i: ', i, 'inequacoes4: ', valor[0])
                cont = cont + 1
        print('cont: ', cont)
        sys.exit(0)
        '''

        matriz_s = []
        for i in range(len(turmas_objetos)):
            if turmas_objetos[i].turno.upper() == 'MATUTINO':   #if turmas_objetos[i].turno == 'Matutino':
                matriz_s.append(0)
            else:
                matriz_s.append(frame_tamanho)
        windows = []
        for i in range(len(professores_objetos)):
            windows.append([])
        fitness2 = 0
        fitness3a = 0
        fitness3b = 0
        fitness4a = 0
        fitness4b = 0
        fitness6 = 0
        fitness7 = 0
        for j in range(len(frame_tuplas_tdp)):
            # print('\nj: ', j, 'len(frame_tuplas_tdp: ', len(frame_tuplas_tdp), 'ii: ', ii)
            fitness = 0
            obj_vez = populacao_atual[ii].individuo
            # print('len(obj_vez: ', len(obj_vez))
            # print('obj_vez[j]: ', obj_vez[j])
            t = obj_vez[j][0]
            d = obj_vez[j][1]
            p = obj_vez[j][2]
            s = matriz_s[t]
            matriz_s[t] = s + 1
            if d != 999:
                # print('\nwindows[p]: ', windows[p])
                if s not in windows[p]:
                    windows[p].append(s)
                # print('t: ', t, 'd: ', d, 'p: ', p, 's: ', s)
                # print('windows[p]: ', windows[p])
                valor_da_vez = lista_tdps[t][d][p][s]
                '''
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '2':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            inequacoes_copia[i][1] = inequacoes_copia[i][1] - 1
                            fitness = fitness + 1
                            # print('valor_da_vez: ', valor_da_vez, '2')
                            break
                '''
                fitness = fitness + 1
                fitness2 = fitness2 + 1

                valor3 = dict3[valor_da_vez]
                if valor3[1] > 0:
                    fitness = fitness + 1
                    fitness3a = fitness3a + 1
                    for i in valor3[0]:
                        temp3 = dict3[i]
                        if temp3[1] > 0:
                            temp3[1] = temp3[1] - 1
                            dict3[i] = temp3
                else:
                    fitness3b = fitness3b + 1
                    if j not in posicao_erro[ii]:
                        posicao_erro[ii].append(j)  # posição sem pontuação


                valor4 = dict4[valor_da_vez]
                if valor4[1] > 0:
                    # fitness = fitness + 1
                    fitness4a = fitness4a + 1
                    for i in valor4[0]:
                        temp4 = dict4[i]
                        # print('temp4: ', temp4)
                        if temp4[1] > 0:
                            temp4[1] = temp4[1] - 1
                            dict4[i] = temp4
                            # print('dict4[i]: ', dict4[i])
                else:
                    fitness4b = fitness4b + 1
                    if j not in posicao_erro[ii]:
                        posicao_erro[ii].append(j)  # posição sem pontuação

                fitness = fitness + 1
                '''
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '6':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            inequacoes_copia[i][1] = inequacoes_copia[i][1] - 1
                            fitness = fitness + 1
                            # print('valor_da_vez: ', valor_da_vez, '6')
                            break
                '''
                fitness = fitness + 1
                fitness6 = fitness6 + 1
                '''
                for i in range(len(inequacoes_copia)):
                    if inequacoes_copia[i][1] > 0 and inequacoes_copia[i][2] == '7':
                        if valor_da_vez in inequacoes_copia[i][0]:
                            inequacoes_copia[i][1] = inequacoes_copia[i][1] - 1
                            fitness = fitness + 1
                            # print('valor_da_vez: ', valor_da_vez, '7\n')
                            break
                '''
                fitness = fitness + 1
                fitness7 = fitness7 + 1
            # print('ii: ', ii, 'teste: ', teste)
            individuo_fitness[ii] = individuo_fitness[ii] + fitness

        # print('-----------------------------------------------------------------------')
        # Neste ponto realizamos a inclusão da restrição das janelas no cálculo do fitness.
        matriz_s = []
        for i in range(len(turmas_objetos)):
            if turmas_objetos[i].turno.upper() == 'MATUTINO':   #if turmas_objetos[i].turno == 'Matutino':
                matriz_s.append(0)
            else:
                matriz_s.append(frame_tamanho)
        windows2 = []
        limite_fitness_janelas = 7000
        windows2 = copy.deepcopy(windows)
        for j in range(len(frame_tuplas_tdp)):
            numero_janelas = 0
            lista = populacao_atual[ii].individuo
            t = lista[j][0]
            d = lista[j][1]
            p = lista[j][2]
            s = matriz_s[t]
            matriz_s[t] = s + 1
            if d != 999:
                ss = slots_objetos[s].slot
                if ss not in windows2[p]:
                    windows2[p].append(ss)
                grade = Grade('1', 'Matutino')
                janelas = grade.janelas()
                for m in range(len(janelas)):
                    for n in range(len(windows2)):
                        if janelas[m][0] in windows2[n] and janelas[m][1] not in windows2[n] and janelas[m][2]\
                                in windows2[n]:
                            numero_janelas = numero_janelas + 1
        if numero_janelas <= limite_fitness_janelas:
            individuo_fitness[ii] = individuo_fitness[ii] + pontos_fitness
        '''
        print(ii, '\nTodas as fitnesses ')
        print(fitness2)
        print(fitness3a, fitness3b, fitness3a + fitness3b)
        print(fitness4a, fitness4b, fitness4a + fitness4b)
        print(fitness6)
        print(fitness7)
        if numero_janelas <= limite_fitness_janelas:
            print(pontos_fitness)
        else:
            print('0')
        '''
        # print('Janelas [', ii, ']: ', numero_janelas)

    percentual_fitness = []
    for i in range(len(individuo_fitness)):
        percentual_fitness.append(0)
        percentual_fitness[i] = individuo_fitness[i] * 100 // max_fit
    print(vez, 'individuo_fitness: ', individuo_fitness, percentual_fitness)

    # Agora é testar se algum indivíduo é resultado válido.
    '''
    for i in range(n_individuos):
        ref_i = []
        ref_i = copy.deepcopy(populacao_atual[i].individuo)
        ref_j = []
        ref_j = copy.deepcopy(frame_tuplas_tdp)
        while len(ref_i) != 0:
            if ref_i[0] in ref_j:
                ref_j.remove(ref_i[0])
                ref_i.pop(0)
            else:
                print('Não são iguais.')
                sys.exit(0)
    print('Tudo igual.')
    '''
    finalizado = False
    for i in range(len(individuo_fitness)):
        if individuo_fitness[i] == 6 * pontos_fitness:
            finalizado = True
            solucao = populacao_atual[i].individuo
            break


    if finalizado:
        matriz_s = []
        for i in range(len(turmas_objetos)):
            if turmas_objetos[i].turno.upper() == 'MATUTINO':   #if turmas_objetos[i].turno == 'Matutino':
                matriz_s.append(0)
            else:
                matriz_s.append(frame_tamanho)
        for i in range(len(solucao)):
            t = solucao[i][0]
            d = solucao[i][1]
            p = solucao[i][2]
            s = matriz_s[t]
            matriz_s[t] = s + 1
            if d != 999:
                ss = slots_objetos[s].slot
                if ss not in windows2[p]:
                    windows2[p].append(ss)
                valor_da_vez = lista_tdps[t][d][p][s]
                lista_sorteados.append(valor_da_vez)
        finalizado = True
        print('Vezes: -----------------------------', vez)

        parcial_janelas = 0
        grade_rodada = Grade('1', 'Matutino')
        janelas1 = grade_rodada.janelas()
        for m in range(len(janelas1)):
            for n in range(len(windows2)):
                if janelas1[m][0] in windows2[n] and janelas1[m][1] not in windows2[n] and janelas1[m][2] \
                        in windows2[n]:
                    parcial_janelas = parcial_janelas + 1
        print('Janelas até aqui: ', parcial_janelas)
    else:
        vez = vez + 1
        # print('Turma: ', t, 'vez: ', vez)
        # temp_inequacoes = copy.deepcopy(inequacoes)
        finalizado = False

    # Vamos isolar os melhores da população, mantendo-os na população nova.
    top_quantidade = 4

    temp_top = []
    temp_top_indices = []
    grupo_melhores_fitnesses = []
    top = []
    for i in range(len(individuo_fitness)):
        if individuo_fitness[i] not in grupo_melhores_fitnesses:
            grupo_melhores_fitnesses.append(individuo_fitness[i])
    grupo_melhores_fitnesses.sort()
    grupo_melhores_fitnesses.reverse()
    # print('grupo_melhores_fitnesses: ', grupo_melhores_fitnesses)
    for i in range(len(grupo_melhores_fitnesses)):
        for j in range(len(individuo_fitness)):
            if grupo_melhores_fitnesses[i] == individuo_fitness[j]:
                # temp_top.append(populacao_atual[j])
                temp_top_indices.append(j)
        if i == 0:
            shuffle(temp_top_indices)   # para possibilitar que novos melhores possam fazer parte do topo.
    for i in range(len(temp_top_indices)):
        temp_top.append(populacao_atual[temp_top_indices[i]])
    for i in range(top_quantidade):
        top.append(temp_top[0])
        temp_top.pop(0)

    # Expandir o resultado absoluto do fitness para resultado relativo do fitness, tomando
    #       como referência o menor valor + 1 [normalização].
    referencia = 500
    for i in range(len(populacao_atual)):
        if individuo_fitness[i] < referencia:
            referencia = individuo_fitness[i]
    for i in range(len(populacao_atual)):
        individuo_fitness[i] = individuo_fitness[i] - referencia + 1
    # Aqui começa a seleção
    # Para selecionar é preciso transformar o valor de fitness em uma escala de 0-10000.
    total = 0
    for i in range(len(populacao_atual)):
        total = total + individuo_fitness[i]
    # print('Total: ', total) # $$$
    roleta_range = []
    for i in range(len(populacao_atual)):
        if i == 0:
            inicio = 0
        else:
            inicio = roleta_range[i - 1][1]
        if i == len(populacao_atual) - 1:
            fim = 10000
        else:
            fim = inicio + (individuo_fitness[i] * 10000 / total)
        roleta_range.append([inicio, fim])
    for i in range(len(populacao_atual)):
        pass
        # print('individuo_fitness_normalizado: ', individuo_fitness[i], roleta_range[i])  # $$$
    selecionados = []
    escolhidos = []
    for i in range(len(populacao_atual)):
        valor = choice(range_10000)
        for j in range(len(populacao_atual)):
            if roleta_range[j][0] <= valor and valor <= roleta_range[j][1]:
                selecionados.append(populacao_atual[j])
                escolhidos.append(j)
    # print('escolhidos_fitness: ', escolhidos) # $$$
    # Neste ponto temos os selecionados.
    lista_crossover = []
    nao_lista_crossover = []
    pc = 90
    cross_indice = []
    nao_cross_indice = []
    for i in range(len(selecionados)):
        valor = choice(range_100)
        if valor <= pc:
            lista_crossover.append(selecionados[i])
            cross_indice.append(escolhidos[i])
        else:
            nao_lista_crossover.append(selecionados[i])
            nao_cross_indice.append(escolhidos[i])
    # Verificar se número ímpar de selecionados:
    if len(lista_crossover) % 2 == 0:
        pass
    else:
        tamanho_lista = len(lista_crossover)
        indice = tamanho_lista - 1
        valor = lista_crossover[indice]
        nao_lista_crossover.append(valor)
        lista_crossover.pop(indice)

        tamanho_lista = len(cross_indice)
        indice = tamanho_lista - 1
        valor = cross_indice[indice]
        nao_cross_indice.append(valor)
        cross_indice.pop(indice)
    # print('escolhidos para cross: ', cross_indice)
    # print('não escolhidos para cross: ', nao_cross_indice)
    # Realizar crossover (position-based crossover)
    # Critério: trocar o conteúdo de posições e manter as outras

    # Então vamos sortear as posições que serão embaralhadas
    trocas_previstas = 50
    if vez % 5 == 0:
        usar_metodo_manipulacao_genetica = False
    else:
        usar_metodo_manipulacao_genetica = False
    troca_n = []
    for i in range(len(populacao_atual)):
        if usar_metodo_manipulacao_genetica:
            troca_n.append(len(posicao_erro[i]))
        else:
            troca_n.append(trocas_previstas)

    buffer_trocados = []
    i = 0
    while i != trocas_previstas:
        sorte = choice(range_elementos)
        if sorte not in buffer_trocados:
            buffer_trocados.append(sorte)
            i = i + 1
    range_troca = []
    for i in range(len(populacao_atual)):
        range_troca.append([])
    for i in range(len(populacao_atual)):
        if usar_metodo_manipulacao_genetica:
            range_troca[i] = copy.deepcopy(posicao_erro[i])
        else:
            range_troca[i] = copy.deepcopy(buffer_trocados)
    # Vamos gerar os filhos.
    '''
    filhos = []
    for i in range(len(lista_crossover)):
        filho = []
        posicao_nova = []
        lista_individuo = lista_crossover[i].individuo
        for j in range(len(range_troca[i])):
            posicao_nova.append(lista_individuo[range_troca[i][j]])
        shuffle(posicao_nova)
        for j in range(len(frame_tuplas_tdp)):
            if j in range_troca[i]:
                filho.append(posicao_nova[0])
                posicao_nova.pop(0)
            else:
                filho.append(lista_individuo[j])
        filhos.append(filho)

    # Realizar mutação (order-based mutation).
    # Varrer posições e aplicar Bernoulli (pm)
    # Se posição for sofrer mutação, sortear outra posição para realizar a troca
    for i in range(len(filhos)):
        for j in range(len(frame_tuplas_tdp)):
            pm = 10
            valor = choice(range_100)
            if valor <= pm:
                temp = filhos[i][j]
                dest = choice(range_elementos)
                filhos[i][j] = filhos[i][dest]
                filhos[i][dest] = temp

    '''
    filhos = []
    fixos = 20
    moveis = frame_tamanho - fixos
    range_0_frame = []
    for k in range(frame_tamanho):
        range_0_frame.append(k)
    for i in range(len(lista_crossover)):
        lista_individuo = lista_crossover[i].individuo
        filho = []
        for j in range(len(turmas_objetos)):
            lista_moveis = []
            buffer_embaralhado = []
            while len(lista_moveis) != moveis:
                nro_sorte = choice(range_0_frame)
                if nro_sorte not in lista_moveis:
                    lista_moveis.append(nro_sorte)
                    buffer_embaralhado.append(lista_individuo[j * frame_tamanho + nro_sorte])
            shuffle(buffer_embaralhado)
            inicio = j * frame_tamanho
            fim = inicio + frame_tamanho
            for m in range(inicio, fim):
                if m in lista_moveis:
                    filho.append(buffer_embaralhado[0])
                    buffer_embaralhado.pop(0)
                else:
                    filho.append(lista_individuo[m])
        filhos.append(filho)




    # Agora junta top, filhos e não escolhidos
    populacao_atual = []
    for i in range(top_quantidade):
        populacao_atual.append(top[i])
    for i in range(len(filhos)):
        populacao_atual.append(Individuo(filhos[i]))
    for i in range(len(nao_lista_crossover)):
        populacao_atual.append(nao_lista_crossover[i])
    populacao_atual.reverse()
    while len(populacao_atual) > n_individuos:
        populacao_atual.pop(0)
    populacao_atual.reverse()

xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(y)):
    if y[i].X == 1:
        cont = cont + 1
print('Total de Y: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
tempo_2 = time.time()
intervalo = (tempo_2 - tempo_1) / 60
print(intervalo, ' minutos.')
# --------------------------------------------------------------------------------------------------------


