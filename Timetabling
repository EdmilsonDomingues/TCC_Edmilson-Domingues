import pandas as pd
import gurobipy as gp

START_POINT = 0
END_POINT = None

# Leitura completa da tabela fornecida
print('Realizando o processo de Leitura.')
df = pd.read_excel('./arquivo_ProjetoUFSC_v1.ods', engine='odf')
df['Código da disc. '] = df['Código da disc. '].astype(str)
print(df.dtypes)
print()
print(df.info())


class Turma:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, tipo_turma,
                 codigo_turno, turno, codigo_area_ensino, area_ensino, tipo_grade):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma    # PK
        self.tipo_turma = tipo_turma
        self.codigo_turno = codigo_turno
        self.turno = turno
        self.codigo_area_ensino = codigo_area_ensino
        self.area_ensino = area_ensino
        self.tipo_grade = tipo_grade

    def numero_turma(self):
        return self.numero_turma


class Disciplina:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, codigo_disciplina,
                 nome_disciplina, quantidade_aulas_semanais, codigo_area_ensino, area_ensino):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma    # PK
        self.codigo_disciplina = codigo_disciplina  # PK
        self.nome_disciplina = nome_disciplina
        self.quantidade_aulas_semanais = quantidade_aulas_semanais
        self.codigo_area_ensino = codigo_area_ensino    # PK
        self.area_ensino = area_ensino

    def numero_turma(self):
        return self.numero_turma

    def codigo_disciplina(self):
        return self.codigo_disciplina

    def codigo_area_ensino(self):
        return self.codigo_area_ensino


class Professor:
    def __init__(self, id_professor, cpf_professor, nome_professor):
        self.id_professor = id_professor
        self.cpf_professor = cpf_professor  # PK
        self.nome_professor = nome_professor

    def cpf_professor(self):
        return self.cpf_professor

    def nome_professor(self):
        return self.nome_professor


class Grade:
    def __init__(self, tipo_grade, turno):
        self.tipo_grade = tipo_grade
        self.turno = turno

    def grade_elementos(self):
        if self.tipo_grade == '1':
            if self.turno == 'todos':
                return ['1', ..., '51']
            else:
                if self.turno == 'Matutino':
                    return ['0', '1', '2', '3', '4', '11', '12', '13', '14',
                            '15', '22', '23', '24', '25', '26', '33', '34',
                            '35', '36', '37', '44', '45', '46', '47', '48']
                else:
                    if self.turno == 'Vespertino':
                        return ['5', '6', '7', '8', '9', '16', '17', '18',
                                '19', '20', '27', '28', '29', '30', '31', '38',
                                '39', '40', '41', '42', '49', '50', '51', '52', '53']
                    else:
                        return ['11', '21', '31', '41', '51']
        '''
        else:
            if self.tipo_grade == '2':
        '''
        return None

    def janelas(self):
        return [['0', '1', '2'], ['1', '2', '3'], ['2', '3', '4'],
                ['5', '6', '7'], ['6', '7', '8'], ['7', '8', '9'],
                ['11', '12', '13'], ['12', '13', '14'], ['13', '14', '15'],
                ['16', '17', '18'], ['17', '18', '19'], ['18', '19', '20'],
                ['22', '23', '24'], ['23', '24', '25'], ['24', '25', '26'],
                ['27', '28', '29'], ['28', '29', '30'], ['29', '30', '31'],
                ['33', '34', '35'], ['34', '35', '36'], ['35', '36', '37'],
                ['38', '39', '40'], ['39', '40', '41'], ['40', '41', '42'],
                ['44', '45', '46'], ['45', '46', '47'], ['46', '47', '48'],
                ['49', '50', '51'], ['50', '51', '52'], ['51', '52', '53']]


class Slot:
    def __init__(self, slot):
        self._slot = slot

    @property
    def slot(self):
        return self._slot

    @slot.setter
    def slot(self, slot_novo):
        self.slot = slot_novo


class GrupoDisciplinas:
    def __init__(self, tipo_grupo, disciplinas):
        self.tipo_grupo = tipo_grupo
        self.disciplinas = disciplinas


# leitura dataframe escola e criação dos objetos correspondentes:
turmas_objetos = []
disciplinas_objetos = []
professores_objetos = []
slots_objetos = []

turmas_ponteiro = 0
disciplinas_ponteiro = 0
professores_ponteiro = 0
slots_ponteiro = 0
estrela_chaves = []

turma_prov = []
disciplina_prov = []
professor_prov = []
slot_prov = []

controle = []

for index, row in df.iterrows():
    # print(row)
    controle.clear()
    turma_prov.clear()
    disciplina_prov.clear()
    professor_prov.clear()

    turma_prov = [row['Matriz curricular'],
                  row['Etapa (séries)'],
                  row['Número da turma'],
                  row['Tipo de turma (prov. não usaremos)'],
                  row['Cod. Turno'],
                  row['Turno'],
                  row['Código da área de ensino'],
                  row['Área de ensino'], '1']
    disciplina_prov = [row['Matriz curricular'],
                       row['Etapa (séries)'],
                       row['Número da turma'],
                       row['Código da disc. '],
                       row['Nome da disc. '],
                       row['Qtd de aulas na semana'],
                       row['Código da área de ensino'],
                       row['Área de ensino']]
    professor_prov = [row['Identificador do prof. '],
                      row['CPF'],
                      row['Nome']]
    grade = Grade('1', turma_prov[5])
    slot_prov = grade.grade_elementos()

    in_turma = False
    indice = 0
    if len(turmas_objetos) > 0:
        for objeto in turmas_objetos:
            if turma_prov[2] == objeto.numero_turma:
                in_turma = True
                break
            indice = indice + 1
    if in_turma:
        controle.append(indice)
    else:
        controle.append(turmas_ponteiro)
        turmas_objetos.append(Turma(turma_prov[0], turma_prov[1], turma_prov[2],
                                    turma_prov[3], turma_prov[4], turma_prov[5],
                                    turma_prov[6], turma_prov[7], turma_prov[8]))
        turmas_ponteiro = turmas_ponteiro + 1

    in_disciplina = False
    indice = 0
    if len(disciplinas_objetos) > 0:
        for objeto in disciplinas_objetos:
            if disciplina_prov[3] == objeto.codigo_disciplina \
                    and disciplina_prov[6] == objeto.codigo_area_ensino:
                in_disciplina = True
                break
            indice = indice + 1
    if in_disciplina:
        controle.append(indice)
    else:
        controle.append(disciplinas_ponteiro)
        disciplinas_objetos.append(Disciplina(disciplina_prov[0], disciplina_prov[1], disciplina_prov[2],
            disciplina_prov[3], disciplina_prov[4], disciplina_prov[5],
            disciplina_prov[6], turma_prov[7]))
        disciplinas_ponteiro = disciplinas_ponteiro + 1

    in_professor = False
    indice = 0
    if len(professores_objetos) > 0:
        for objeto in professores_objetos:
            if professor_prov[1] == objeto.cpf_professor:
                in_professor = True
                break
            indice = indice + 1
    if in_professor:
        controle.append(indice)
    else:
        controle.append(professores_ponteiro)
        professores_objetos.append(Professor(professor_prov[0], professor_prov[1], professor_prov[2]))
        professores_ponteiro = professores_ponteiro + 1

    # # print('slot_prov: ', slot_prov)
    for slots in slot_prov:
        in_slot = False
        indice = 0
        if len(slots_objetos) > 0:
            for objeto in slots_objetos:
                if slots == objeto.slot:
                    in_slot = True
                    break
                indice = indice + 1
        if in_slot:
            # controle.append(indice)
            # print('indice: ', indice)
            lista = [controle[0], controle[1], controle[2], indice]
            if lista not in estrela_chaves:
                estrela_chaves.append(lista)
        else:
            # controle.append(slots_ponteiro)
            # print('slots_ponteiro: ', slots_ponteiro)
            lista = [controle[0], controle[1], controle[2], slots_ponteiro]
            if lista not in estrela_chaves:
                # #print('Lista: ', lista)
                estrela_chaves.append(lista)
                slots_objetos.append(Slot(slots))
                slots_ponteiro = slots_ponteiro + 1
# #print(estrela_chaves)
'''
for i in range(len(estrela_chaves)):
    print(turmas_objetos[estrela_chaves[i][0]].numero_turma,
          disciplinas_objetos[estrela_chaves[i][1]].codigo_disciplina,
          professores_objetos[estrela_chaves[i][2]].nome_professor,
          slots_objetos[estrela_chaves[i][3]].slot)
'''
print(len(estrela_chaves))
print(len(turmas_objetos))
print(len(disciplinas_objetos))
print(len(professores_objetos))
print(len(slots_objetos))

# [18/01/2023]
# Nesta parte do programa serão introduzidas as regras referentes à pesquisa operacional.
# 1) Variáveis do problema de Timetabling.
#
#      As listas "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos" são compostas
#      por objetos exclusivos, o que significa que, por exemplo, "turmas_objetos" possui todas as turmas da escola
#      que está sendo considerada.
#      Já a lista "estrela_chaves" possui todas as combinações possíveis para os elementos das listas
#      "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos". A estas combinações
#      serão consideradas variáveis para a esolução do problema.
#      Considerar X[t, d, p, s] como sendo a variável de interesse.

# Em uma avaliação preliminar do arquivo que temos em mãos, existem 7.525 combinações válidas t, d, p, s.
# T: 41 turmas
# D: 26 disciplinas
# P: 52 professores
# S: 50 slots

m = gp.Model("Timetabling")
# ... Variáveis da Pesquisa Operacional:
x_tdps = [i for i in range(len(estrela_chaves))]
x = m.addVars(x_tdps, vtype=gp.GRB.BINARY)


pj = []     # tuplas professor-janela [p, s]
cont_pj = 0
buffer_s = []  # tdps associado a cada slot
s0 = []
s1 = []
s2 = []
somas = []
for i in range(len(slots_objetos)):
    buffer_s.append([])
print(buffer_s)
for i in range(len(estrela_chaves)):
    estrela_chaves[i].append(i)
    buffer_s[estrela_chaves[i][3]].append(estrela_chaves[i])

grade = Grade('1', 'Matutino')
janelas = grade.janelas()
cont_ypj = 0
for professor in range(len(professores_objetos)):
    for jan in janelas:     # tuplas (s0, s1, s2)
        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[0] == slots_objetos[indice].slot:
                pos_s0 = indice
                obj_existe = True
        if not obj_existe:
            break

        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[1] == slots_objetos[indice].slot:
                pos_s1 = indice
                obj_existe = True
        if not obj_existe:
            break

        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[2] == slots_objetos[indice].slot:
                pos_s2 = indice
                obj_existe = True
        if not obj_existe:
            break

    s0.clear()
    s1.clear()
    s2.clear()
    s0_existe = False
    s1_existe = False
    s2_existe = False
    if professor in buffer_s[pos_s0][2]:
        s0.append(buffer_s[pos_s0][4])
        s0_existe = True
    if professor in buffer_s[pos_s1][2]:
        s1.append(buffer_s[pos_s1][4])
        s1_existe = True
    if professor in buffer_s[pos_s2][2]:
        s2.append(buffer_s[pos_s2][4])
        s2_existe = True
    if s0_existe and s1_existe and s2_existe:
        # somas[cont_ypj] = [s0.copy(), s1.copy(), s2.copy()]
        # pj[cont_ypj] = [professor, jan]
        somas.append([s0.copy(), s1.copy(), s2.copy()])
        pj.append([professor, jan])
        cont_pj = cont_pj + 1

y_pj = [i for i in range(len(pj))]
y = m.addVars(y_pj, vtype=gp.GRB.BINARY)

for cont in range(len(y_pj)):
    '''
    m.addConstr(gp.quicksum(2 * (somas[cont][0]) for cont in len(somas[cont][0])\
                                 - (somas[cont][1]) for cont in len(somas[cont][1])\
                                    + 2 * (somas[cont][2]) for cont in len(somas[cont][2]) <= 9 * y[cont]),
                 "RESTRIÇÃO janelas: p_" +str(pj[cont][0]) + " j_" +str(pj[cont][1]))
    '''
    m.addConstr(gp.quicksum(2 * (somas[cont][0]) for cont in len(somas[cont][0])\
                                 - (somas[cont][1]) for cont in len(somas[cont][1])\
                                    + 2 * (somas[cont][2]) for cont in len(somas[cont][2]) <= 9 * y[cont]),
                 "RESTRIÇÃO janelas: p_" +str(pj[cont][0]) + " j_" +str(pj[cont][1]))
 # ... Função Objetivo da Pesquisa Operacional:
m.setObjective(gp.quicksum(y[i] for i in range(len(y_pj))),sense= gp.GRB.MINIMIZE)

# ... Restrições da Pesquisa Operacional:
# RESTRIÇÃO 3:
ps_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][2], estrela_chaves[cont][3]] not in ps_lista:
        ps_lista.append([estrela_chaves[cont][2], estrela_chaves[cont][3]])
tdps_lista = []
for ps in ps_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][2], estrela_chaves[cont][3]] == ps:
            tdps_lista.append(cont)
    m.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1,
                 "RESTRIÇÃO 3: p_" +str(estrela_chaves[cont][2]) + " s_" +str(estrela_chaves[cont][3]))

m.optimize()
