import gurobipy as gp
import pandas as pd
import copy
import time
import sys
from prettytable import PrettyTable
from random import choice, shuffle

START_POINT = 0
END_POINT = None

# Leitura completa da tabela fornecida
print('Realizando o processo de Leitura.')
df = pd.read_excel('./arquivo_ProjetoUFSC_v1.ods', engine='odf')
df['Código da disc. '] = df['Código da disc. '].astype(str)
# print(df.dtypes)
# print()
# print(df.info())


class Turma:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, tipo_turma,
                 codigo_turno, turno, codigo_area_ensino, area_ensino, tipo_grade):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma  # PK
        self.tipo_turma = tipo_turma
        self.codigo_turno = codigo_turno
        self.turno = turno
        self.codigo_area_ensino = codigo_area_ensino
        self.area_ensino = area_ensino
        self.tipo_grade = tipo_grade

    def numero_turma(self):
        return self.numero_turma


class Disciplina:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, codigo_disciplina,
                 nome_disciplina, quantidade_aulas_semanais, codigo_area_ensino, area_ensino):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma  # PK
        self.codigo_disciplina = codigo_disciplina  # PK
        self.nome_disciplina = nome_disciplina
        self.quantidade_aulas_semanais = quantidade_aulas_semanais
        self.codigo_area_ensino = codigo_area_ensino  # PK
        self.area_ensino = area_ensino

    def numero_turma(self):
        return self.numero_turma

    def codigo_disciplina(self):
        return self.codigo_disciplina

    def codigo_area_ensino(self):
        return self.codigo_area_ensino

    def quantidade_aulas_semanais(self):
        return self.quantidade_aulas_semanais


class Professor:
    def __init__(self, id_professor, cpf_professor, nome_professor):
        self.id_professor = id_professor
        self.cpf_professor = cpf_professor  # PK
        self.nome_professor = nome_professor

    def cpf_professor(self):
        return self.cpf_professor

    def nome_professor(self):
        return self.nome_professor


class Grade:
    def __init__(self, tipo_grade, turno):
        self.tipo_grade = tipo_grade
        self.turno = turno

    def grade_elementos(self):
        if self.tipo_grade == '1':
            if self.turno == 'todos':
                return ['1', ..., '51']
            else:
                if self.turno == 'Matutino':
                    return ['0', '1', '2', '3', '4', '11', '12', '13', '14',
                            '15', '22', '23', '24', '25', '26', '33', '34',
                            '35', '36', '37', '44', '45', '46', '47', '48']
                else:
                    if self.turno == 'Vespertino':
                        return ['5', '6', '7', '8', '9', '16', '17', '18',
                                '19', '20', '27', '28', '29', '30', '31', '38',
                                '39', '40', '41', '42', '49', '50', '51', '52', '53']
                    else:
                        return ['10', '21', '32', '43', '54']
        '''
        else:
            if self.tipo_grade == '2':
        '''
        return None

    def janelas(self):
        return [['0', '1', '2'], ['1', '2', '3'], ['2', '3', '4'],
                ['5', '6', '7'], ['6', '7', '8'], ['7', '8', '9'],
                ['11', '12', '13'], ['12', '13', '14'], ['13', '14', '15'],
                ['16', '17', '18'], ['17', '18', '19'], ['18', '19', '20'],
                ['22', '23', '24'], ['23', '24', '25'], ['24', '25', '26'],
                ['27', '28', '29'], ['28', '29', '30'], ['29', '30', '31'],
                ['33', '34', '35'], ['34', '35', '36'], ['35', '36', '37'],
                ['38', '39', '40'], ['39', '40', '41'], ['40', '41', '42'],
                ['44', '45', '46'], ['45', '46', '47'], ['46', '47', '48'],
                ['49', '50', '51'], ['50', '51', '52'], ['51', '52', '53']]

    def grade_vazia(self):
        lista = [['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', '']]
        return lista

    def dias_semana(self):
        lista_ds = [['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
                    ['11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21'],
                    ['22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32'],
                    ['33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43'],
                    ['44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54']]
        return lista_ds

    def cabecalho(self):
        return ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta']

    def converte_slot_lc(self, slot):
        lista_lc = [[0, 0], [1, 0], [2, 0], [3,0], [4, 0], [6, 0],[7, 0], [8, 0], [9, 0], [10,0], [12, 0],
                    [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [6, 1], [7, 1], [8, 1], [9, 1], [10, 1], [12, 1],
                    [0, 2], [1, 2], [2, 2], [3, 2], [4, 2], [6, 2], [7, 2], [8, 2], [9, 2], [10, 2], [12, 2],
                    [0, 3], [1, 3], [2, 3], [3, 3], [4, 3], [6, 3], [7, 3], [8, 3], [9, 3], [10, 3], [12, 3],
                    [0, 4], [1, 4], [2, 4], [3, 4], [4, 4], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [12, 4]]
        return lista_lc[slot][0], lista_lc[slot][1]


class Slot:
    def __init__(self, slot):
        self._slot = slot

    @property
    def slot(self):
        return self._slot

    @slot.setter
    def slot(self, slot_novo):
        self.slot = slot_novo


class GrupoDisciplinas:
    def __init__(self, tipo_grupo, disciplinas):
        self.tipo_grupo = tipo_grupo
        self.disciplinas = disciplinas


# leitura dataframe escola e criação dos objetos correspondentes:
turmas_objetos = []
disciplinas_objetos = []
professores_objetos = []
slots_objetos = []

turmas_ponteiro = 0
disciplinas_ponteiro = 0
professores_ponteiro = 0
slots_ponteiro = 0
estrela_chaves = []

turma_prov = []
disciplina_prov = []
professor_prov = []
slot_prov = []

controle = []

for index, row in df.iterrows():
    # print(row)
    if row['Código da disc. '] != '611' and row['Código da disc. '] != '1344':
        controle.clear()
        turma_prov.clear()
        disciplina_prov.clear()
        professor_prov.clear()

        turma_prov = [row['Matriz curricular'],
                      row['Etapa (séries)'],
                      row['Número da turma'],
                      row['Tipo de turma (prov. não usaremos)'],
                      row['Cod. Turno'],
                      row['Turno'],
                      row['Código da área de ensino'],
                      row['Área de ensino'], '1']
        disciplina_prov = [row['Matriz curricular'],
                           row['Etapa (séries)'],
                           row['Número da turma'],
                           row['Código da disc. '],
                           row['Nome da disc. '],
                           row['Qtd de aulas na semana'],
                           row['Código da área de ensino'],
                           row['Área de ensino']]
        professor_prov = [row['Identificador do prof. '],
                          row['CPF'],
                          row['Nome']]
        grade = Grade('1', turma_prov[5])
        slot_prov = grade.grade_elementos()

        in_turma = False
        indice = 0
        if len(turmas_objetos) > 0:
            for objeto in turmas_objetos:
                if turma_prov[2] == objeto.numero_turma:
                    in_turma = True
                    break
                indice = indice + 1
        if in_turma:
            controle.append(indice)
        else:
            controle.append(turmas_ponteiro)
            turmas_objetos.append(Turma(turma_prov[0], turma_prov[1], turma_prov[2],
                                        turma_prov[3], turma_prov[4], turma_prov[5],
                                        turma_prov[6], turma_prov[7], turma_prov[8]))
            turmas_ponteiro = turmas_ponteiro + 1

        in_disciplina = False
        indice = 0
        if len(disciplinas_objetos) > 0:
            for objeto in disciplinas_objetos:
                if disciplina_prov[3] == objeto.codigo_disciplina \
                        and disciplina_prov[6] == objeto.codigo_area_ensino \
                        and disciplina_prov[1] == objeto.etapa_serie:
                    in_disciplina = True
                    break
                indice = indice + 1
        if in_disciplina:
            controle.append(indice)
        else:
            controle.append(disciplinas_ponteiro)
            disciplinas_objetos.append(Disciplina(disciplina_prov[0], disciplina_prov[1], disciplina_prov[2],
                                                  disciplina_prov[3], disciplina_prov[4], disciplina_prov[5],
                                                  disciplina_prov[6], turma_prov[7]))
            disciplinas_ponteiro = disciplinas_ponteiro + 1

        in_professor = False
        indice = 0
        if len(professores_objetos) > 0:
            for objeto in professores_objetos:
                if professor_prov[1] == objeto.cpf_professor:
                    in_professor = True
                    break
                indice = indice + 1
        if in_professor:
            controle.append(indice)
        else:
            controle.append(professores_ponteiro)
            professores_objetos.append(Professor(professor_prov[0], professor_prov[1], professor_prov[2]))
            professores_ponteiro = professores_ponteiro + 1

        # # print('slot_prov: ', slot_prov)
        for slots in slot_prov:
            in_slot = False
            indice = 0
            if len(slots_objetos) > 0:
                for objeto in slots_objetos:
                    if slots == objeto.slot:
                        in_slot = True
                        break
                    indice = indice + 1
            if in_slot:
                # controle.append(indice)
                # print('indice: ', indice)
                lista = [controle[0], controle[1], controle[2], indice]
                if lista not in estrela_chaves:
                    estrela_chaves.append(lista)
            else:
                # controle.append(slots_ponteiro)
                # print('slots_ponteiro: ', slots_ponteiro)
                lista = [controle[0], controle[1], controle[2], slots_ponteiro]
                if lista not in estrela_chaves:
                    # #print('Lista: ', lista)
                    estrela_chaves.append(lista)
                    slots_objetos.append(Slot(slots))
                    slots_ponteiro = slots_ponteiro + 1
# #print(estrela_chaves)
'''
for i in range(len(estrela_chaves)):
    print(turmas_objetos[estrela_chaves[i][0]].numero_turma,
          disciplinas_objetos[estrela_chaves[i][1]].codigo_disciplina,
          professores_objetos[estrela_chaves[i][2]].nome_professor,
          slots_objetos[estrela_chaves[i][3]].slot)
'''
print(len(estrela_chaves))
print(len(turmas_objetos))
print(len(disciplinas_objetos))
print(len(professores_objetos))
print(len(slots_objetos))

# [18/01/2023]
# Nesta parte do programa serão introduzidas as regras referentes à pesquisa operacional.
# 1) Variáveis do problema de Timetabling.
#
#      As listas "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos" são compostas
#      por objetos exclusivos, o que significa que, por exemplo, "turmas_objetos" possui todas as turmas da escola
#      que está sendo considerada.
#      Já a lista "estrela_chaves" possui todas as combinações possíveis para os elementos das listas
#      "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos". A estas combinações
#      serão consideradas variáveis para a esolução do problema.
#      Considerar X[t, d, p, s] como sendo a variável de interesse.

# Em uma avaliação preliminar do arquivo que temos em mãos, existem 7.525 combinações válidas t, d, p, s.
# T: 41 turmas
# D: 26 disciplinas
# P: 52 professores
# S: 50 slots

model = gp.Model("Timetabling")
# Variáveis da Pesquisa Operacional:
x_tdps = [i for i in range(len(estrela_chaves))]
x = model.addVars(x_tdps, vtype=gp.GRB.BINARY)
# Criação das variáveis Y:
pj = []  # tuplas professor-janela [p, s]
cont_pj = 0
buffer_s = []  # tdps associado a cada slot
s0 = []
s1 = []
s2 = []
somas = []
for i in range(len(slots_objetos)):
    buffer_s.append([])
for i in range(len(estrela_chaves)):
    estrela_chaves[i].append(i)
    buffer_s[estrela_chaves[i][3]].append(estrela_chaves[i])
grade = Grade('1', 'Matutino')
janelas = grade.janelas()
cont_ypj = 0
for professor in range(len(professores_objetos)):
    for jan in janelas:  # tuplas (s0, s1, s2)
        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[0] == slots_objetos[indice].slot:
                pos_s0 = indice
                obj_existe = True
                break
        if not obj_existe:
            break

        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[1] == slots_objetos[indice].slot:
                pos_s1 = indice
                obj_existe = True
                break
        if not obj_existe:
            break

        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[2] == slots_objetos[indice].slot:
                pos_s2 = indice
                obj_existe = True
                break
        if not obj_existe:
            break

        s0.clear()
        s1.clear()
        s2.clear()
        s0_existe = False
        s1_existe = False
        s2_existe = False
        # print('buffer_s[0]: ', buffer_s[0])
        for i in range(len(buffer_s[pos_s0])):
            if professor == buffer_s[pos_s0][i][2]:
                s0.append(buffer_s[pos_s0][i][4])
                s0_existe = True
        for i in range(len(buffer_s[pos_s1])):
            if professor == buffer_s[pos_s1][i][2]:
                s1.append(buffer_s[pos_s1][i][4])
                s1_existe = True
        for i in range(len(buffer_s[pos_s2])):
            if professor == buffer_s[pos_s2][i][2]:
                s2.append(buffer_s[pos_s2][i][4])
                s2_existe = True
        if s0_existe and s1_existe and s2_existe:
            somas.append([copy.deepcopy(s0), copy.deepcopy(s1), copy.deepcopy(s2)])
            pj.append([professor, jan])
            # print('pj: ', pj)
            # print('somas: ', somas)
            # print()
            cont_pj = cont_pj + 1

y_pj = [i for i in range(len(pj))]
y = model.addVars(y_pj, vtype=gp.GRB.BINARY)
tolerancia = 0.0001
# print(somas)
for cont in range(len(somas)):
    # print('somas: ', somas[cont][0])
    # print('somas: ', somas[cont][1])
    # print('somas: ', somas[cont][2])
    # print(x)
    # print(y)
    # print('len(somas[cont][0])): ', len(somas[cont][0]))
    '''
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) + 6 >= (9 * y[cont]==1 +
                                                                                                      tolerancia),
    '''
    eps = 0.0001
    M = 10 + eps    # smallest possible given bounds on x and y

    # Model if x > y, then b = 1, otherwise b = 0
    # m.addConstr(x >= y + eps - M * (1 - b), name="bigM_constr1")
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) >= 3 + eps\
                    - M * (1 - y[cont]), name="RESTRIÇÃO janelas >: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))
    # m.addConstr(x <= y + M * b, name="bigM_constr2")
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) <= 3\
                    + M * y[cont], name="RESTRIÇÃO janelas <: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))
# --------------------------------------------------------------------------------------------------------
# Função Objetivo da Pesquisa Operacional:
model.setObjective(gp.quicksum(y[i] for i in range(len(y_pj))), sense=gp.GRB.MINIMIZE)
# --------------------------------------------------------------------------------------------------------
# Restrições da Pesquisa Operacional:
inequacoes = []

# RESTRIÇÃO 2:
ts_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][3]] not in ts_lista:
        ts_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][3]])
tdps_lista = []
for ts in ts_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][3]] == ts:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1, "RESTRIÇÃO 2: t_" + str(ts[0]) + " s_" + str(ts[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1, '2'])

# RESTRIÇÃO 3:
ps_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][2], estrela_chaves[cont][3]] not in ps_lista:
        ps_lista.append([estrela_chaves[cont][2], estrela_chaves[cont][3]])
tdps_lista = []
for ps in ps_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][2], estrela_chaves[cont][3]] == ps:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1,
                        "RESTRIÇÃO 3: p_" + str(ps[0]) + " s_" + str(ps[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1, '3'])

# RESTRIÇÃO 4:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
grade = Grade('1', 'Matutino')
ds_lista = grade.dias_semana()
dias = grade.cabecalho()
'''
for i in range(5):
    lista_um_ds = ds_lista[i]
    for td in td_lista:
        tdps_lista.clear()
        for cont in range(len(estrela_chaves)):
            if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
                if disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais <= 5:
                    if slots_objetos[estrela_chaves[cont][3]].slot in lista_um_ds:
                        tdps_lista.append(cont)
        if len(tdps_lista) > 0:
            model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <=1,
                            "RESTRIÇÃO 4: t_" + str(td[0]) + " d_" + str(td[1]) + " ds_" + dias[i])
            inequacoes.append([copy.deepcopy(tdps_lista), 1, '4'])
'''
for i in range(5):
    lista_um_ds = ds_lista[i]
    for td in td_lista:
        tdps_lista.clear()
        for cont in range(len(estrela_chaves)):
            if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
                resto = disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais % 5
                if resto == 0:
                    razao = int(disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais / 5)
                else:
                    razao = int(disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais / 5) + 1
                if slots_objetos[estrela_chaves[cont][3]].slot in lista_um_ds:
                    tdps_lista.append(cont)
        if len(tdps_lista) > 0:
            model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= razao,
                            "RESTRIÇÃO 4: t_" + str(td[0]) + " d_" + str(td[1]) + " ds_" + dias[i])
            inequacoes.append([copy.deepcopy(tdps_lista), razao, '4'])

# RESTRIÇÃO 6:
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
lista_disc = []
teste = 0
for p in p_lista:
    # print('p: ', p)
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    # print('tdps_lista: ', tdps_lista)
    lista_disc.clear()
    for i in range(len(tdps_lista)):
        if [estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]] not in lista_disc:
            lista_disc.append([estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]])
    soma = 0
    # print('disc: ', lista_disc)
    for i in range(len(lista_disc)):
        soma = soma + disciplinas_objetos[lista_disc[i][1]].quantidade_aulas_semanais
        # print('parcela: ', disciplinas_objetos[lista_disc[i][1]].quantidade_aulas_semanais)
        # print(soma)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) == soma, "RESTRIÇÃO 6: p_" + str(p))
        inequacoes.append([copy.deepcopy(tdps_lista), soma, '6'])


# RESTRIÇÃO 7:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
for td in td_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) == disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]]\
                        .quantidade_aulas_semanais, "RESTRIÇÃO 7: t_" + str(td[0]) + " d_" + str(td[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]]\
                        .quantidade_aulas_semanais, '7'])

# --------------------------------------------------------------------------------------------------------
# Execução da modelagem:
model.optimize()
# print(model.display())

'''
print(len(x))
print(len(y))
print(x)
for i in range(len(x)):
    print('x[', i, '] = ', x[i].X)
'''
# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):

p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        if x[tdps_lista[i]].X == 1:
        # if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "Turma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma)\
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)\
                + "\n" + "C: " + x[tdps_lista[i]].varName
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Professor(a): ', professores_objetos[p].nome_professor)
    print(apresentacao)

t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        if x[tdps_lista[i]].X == 1:
        # if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                    + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                    + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma: ', turmas_objetos[t].numero_turma)
    print(apresentacao)

# --------------------------------------------------------------------------------------------------------
'''
# Recorrência se resultado for Unfeasible:

# model.write("model.ilp")

# From "https://www.gurobi.com/documentation/10.0/examples/workforce2_py.html#subsubsection:workforce2.py":
status = model.Status
if status == gp.GRB.UNBOUNDED:
    print('The model cannot be solved because it is unbounded')
    sys.exit(0)
if status == gp.GRB.OPTIMAL:
    print('The optimal objective is %g' % model.ObjVal)
    sys.exit(0)
if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
    print('Optimization was stopped with status %d' % status)
    sys.exit(0)

# do IIS
print('The model is infeasible; computing IIS')
removed = []

# Loop until we reduce to a model that can be solved
while True:

    model.computeIIS()
    print('\nThe following constraint cannot be satisfied:')
    for c in model.getConstrs():
        if c.IISConstr:
            print('%s' % c.ConstrName)
            # Remove a single constraint from the model
            removed.append(str(c.ConstrName))
            model.remove(c)
            break
    print('')

    model.optimize()
    status = model.Status

    if status == gp.GRB.UNBOUNDED:
        print('The model cannot be solved because it is unbounded')
        sys.exit(0)
    if status == gp.GRB.OPTIMAL:
        break
    if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
        print('Optimization was stopped with status %d' % status)
        sys.exit(0)

print('\nThe following constraints were removed to get a feasible LP:')
print(removed)
'''
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# Sequência aleatória
'''
c = []
lista_sorteados = []
for i in range(len(x)):
    c.append(i)
existe_valor = True
while existe_valor and len(c) != 0:
    valor_da_vez = choice(c)
    tem_7 = False
    tem_6 = False
    tem_3 = False
    tem_2 = False

    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '2':
            if valor_da_vez in inequacoes[i][0]:
                tem_2 = True
                break

    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '3':
            if valor_da_vez in inequacoes[i][0]:
                tem_3 = True
                break

    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '6':
            if valor_da_vez in inequacoes[i][0]:
                tem_6 = True
                break
    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
            if valor_da_vez in inequacoes[i][0]:
                tem_7 = True
                break

    if tem_2 and tem_3 and tem_6 and tem_7:
        lista_sorteados.append(valor_da_vez)
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and valor_da_vez in inequacoes[i][0]:
                # inequacoes[i][0].remove(valor_da_vez)
                inequacoes[i][1] = inequacoes[i][1] - 1
    c.remove(valor_da_vez)
    existe_valor = False
    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
            existe_valor = True
            break

for i in range(len(inequacoes)):
    print(inequacoes[i])
xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)
'''
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# Sequência priorizada
'''
c = []
lista_sorteados = []

# for i in range(len(x)):
    # c.append(i)

for prof_ind in range(len(professores_objetos)):
    for turma_ind in range(len(turmas_objetos)):
        for todos_ind in range(len(estrela_chaves)):
            if prof_ind == estrela_chaves[todos_ind][2] and turma_ind == estrela_chaves[todos_ind][0]:
                c.append(todos_ind)
print('c: ', c)
print('len(c): ', len(c))
existe_valor = True
while existe_valor and len(c) != 0:
    # valor_da_vez = choice(c)
    valor_da_vez = c[0]
    print(valor_da_vez)
    print('Turma: ', turmas_objetos[estrela_chaves[valor_da_vez][0]].numero_turma, ', ',
          estrela_chaves[valor_da_vez][0])
    print('Disciplina: ', disciplinas_objetos[estrela_chaves[valor_da_vez][1]].nome_disciplina, ', ',
          estrela_chaves[valor_da_vez][1])
    print('Professor: ', professores_objetos[estrela_chaves[valor_da_vez][2]].nome_professor, ', ',
          estrela_chaves[valor_da_vez][2])
    print('Slot: ', slots_objetos[estrela_chaves[valor_da_vez][3]].slot)
    tem_7 = False
    tem_6 = False
    tem_3 = False
    tem_2 = False

    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '2':
            if valor_da_vez in inequacoes[i][0]:
                tem_2 = True
                # print(inequacoes[i])
                break

    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '3':
            if valor_da_vez in inequacoes[i][0]:
                tem_3 = True
                # print(inequacoes[i])
                break

    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '6':
            if valor_da_vez in inequacoes[i][0]:
                tem_6 = True
                # print(inequacoes[i])
                break

    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
            if valor_da_vez in inequacoes[i][0]:
                tem_7 = True
                # print(inequacoes[i])
                break

    if tem_2 and tem_3 and tem_6 and tem_7:
        lista_sorteados.append(valor_da_vez)
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and valor_da_vez in inequacoes[i][0]:
                # inequacoes[i][0].remove(valor_da_vez)
                inequacoes[i][1] = inequacoes[i][1] - 1
                # print('depois: ', inequacoes[i])
    # print()
    c.remove(valor_da_vez)
    existe_valor = False
    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
            existe_valor = True
            break
xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)
'''
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# Esta heurística é global - avalia, para cada tupla (t, d, p) estabelecida, e para seus N filhos factíveis,
# qual o que apresenta o menor número de utilização (distribuição equânime entre slots).
'''
c = []
lista_sorteados = []
heuristica = []
for i in range(55):
    heuristica.append(0)
for i in range(len(x)):
    c.append(i)
print('c: ', c)
print('len(c): ', len(c))
base = 0
existe_valor = True
while existe_valor and len(c) != 0:
    # valor_da_vez = choice(c)
    valor_da_vez = c[0]
    # print('Len(c): ', len(c))
    for i in range(len(estrela_chaves)):
        # print(i)
        if estrela_chaves[valor_da_vez][0] == estrela_chaves[i][0] and\
                estrela_chaves[valor_da_vez][1] == estrela_chaves[i][1] and\
                estrela_chaves[valor_da_vez][2] == estrela_chaves[i][2]:
            base = i
            break
    sec = []
    existe_slot = True
    while existe_slot and base <= len(estrela_chaves) - 1:
        if estrela_chaves[valor_da_vez][0] == estrela_chaves[base][0] and estrela_chaves[valor_da_vez][1] == estrela_chaves[base][1] and estrela_chaves[valor_da_vez][2] == estrela_chaves[base][2]:
            sec.append(base)   # para avaliar quais slots apresentam factibilidade.
            base = base + 1
            existe_slot = True
        else:
            existe_slot = False

    slots_factiveis = []
    # print('sec: ', sec)
    for m in range(len(sec)):
        tem_7 = False
        tem_6 = False
        tem_3 = False
        tem_2 = False
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '2':
                if sec[m] in inequacoes[i][0]:
                    tem_2 = True
                    break

        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '3':
                if sec[m] in inequacoes[i][0]:
                    tem_3 = True
                    break

        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '6':
                if sec[m] in inequacoes[i][0]:
                    tem_6 = True
                    break

        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
                if sec[m] in inequacoes[i][0]:
                    tem_7 = True
                    break

        if tem_2 and tem_3 and tem_6 and tem_7:
            slots_factiveis.append(sec[m])
        else:
            try:
                c.remove(sec[m])
            except:
                pass
    # print('Slots factíveis: ', slots_factiveis)
    # Avaliar heurística:
    if len(slots_factiveis) == 0:
        # c.remove(valor_da_vez)
        pass
    else:
        menor = 10000
        posicao = 0
        for j in range(len(slots_factiveis)):
            if heuristica[estrela_chaves[slots_factiveis[j]][3]] <= menor:
                posicao = j
                menor = heuristica[estrela_chaves[slots_factiveis[j]][3]]
        lista_sorteados.append(slots_factiveis[posicao])
        # heuristica[posicao] = heuristica[posicao] + 1
        heuristica[estrela_chaves[slots_factiveis[posicao]][3]] = heuristica[estrela_chaves[slots_factiveis[posicao]][3]] + 1
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and slots_factiveis[posicao] in inequacoes[i][0]:
                inequacoes[i][1] = inequacoes[i][1] - 1
        c.remove(slots_factiveis[posicao])

    existe_valor = False
    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
            existe_valor = True
            break
xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)
print('Heurística: ', heuristica)
'''
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# Esta heurística é global - avalia, para cada tupla (t, d, p) estabelecida, e para seus N filhos factíveis,
# qual o que apresenta o menor número de utilização (distribuição equânime entre slots).
'''
conexoes_prof = []
soma_conexoes = 0
for i in range(len(professores_objetos)):
    for j in range(len(estrela_chaves)):
        if i == estrela_chaves[j][2]:
            soma_conexoes = soma_conexoes + 1
    conexoes_prof.append(soma_conexoes/25)
    soma_conexoes = 0
prof_obj = [7, 8, 22, 19, 37, 9, 0, 6, 21, 23, 24, 32, 35, 26, 31, 1, 4, 38, 15, 16, 17, 30, 36, 10, 28, 3, 18, 33, 5,
        11, 13, 14, 20, 25, 27, 34, 39, 2, 12, 29]
c = []
lista_sorteados = []
heuristica = []

for i in range(55):
    heuristica.append(0)

for prof_ind in prof_obj:
    for turma_ind in range(len(turmas_objetos)):
        for todos_ind in range(len(estrela_chaves)):
            if prof_ind == estrela_chaves[todos_ind][2] and turma_ind == estrela_chaves[todos_ind][0]:
                c.append(todos_ind)


# for i in range(len(x)):
    # c.append(i)

print('c: ', c)
print('len(c): ', len(c))
base = 0
existe_valor = True
while existe_valor and len(c) != 0:
    # valor_da_vez = choice(c)
    valor_da_vez = c[0]
    # print('Len(c): ', len(c))
    for i in range(len(estrela_chaves)):
        # print(i)
        if estrela_chaves[valor_da_vez][0] == estrela_chaves[i][0] and\
                estrela_chaves[valor_da_vez][1] == estrela_chaves[i][1] and\
                estrela_chaves[valor_da_vez][2] == estrela_chaves[i][2]:
            base = i
            break
    sec = []
    existe_slot = True
    while existe_slot and base <= len(estrela_chaves) - 1:
        if estrela_chaves[valor_da_vez][0] == estrela_chaves[base][0] and estrela_chaves[valor_da_vez][1] == estrela_chaves[base][1] and estrela_chaves[valor_da_vez][2] == estrela_chaves[base][2]:
            sec.append(base)   # para avaliar quais slots apresentam factibilidade.
            base = base + 1
            existe_slot = True
        else:
            existe_slot = False

    slots_factiveis = []
    # print('sec: ', sec)
    for m in range(len(sec)):
        tem_7 = False
        tem_6 = False
        tem_3 = False
        tem_2 = False
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '2':
                if sec[m] in inequacoes[i][0]:
                    tem_2 = True
                    break

        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '3':
                if sec[m] in inequacoes[i][0]:
                    tem_3 = True
                    break

        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '6':
                if sec[m] in inequacoes[i][0]:
                    tem_6 = True
                    break

        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
                if sec[m] in inequacoes[i][0]:
                    tem_7 = True
                    break

        if tem_2 and tem_3 and tem_6 and tem_7:
            slots_factiveis.append(sec[m])
        else:
            try:
                c.remove(sec[m])
            except:
                pass
    # print('Slots factíveis: ', slots_factiveis)
    # Avaliar heurística:
    if len(slots_factiveis) == 0:
        # c.remove(valor_da_vez)
        pass
    else:
        maior = -1
        posicao = 0
        for j in range(len(slots_factiveis)):
            if heuristica[estrela_chaves[slots_factiveis[j]][3]] > maior:
                posicao = j
                maior = heuristica[estrela_chaves[slots_factiveis[j]][3]]
        lista_sorteados.append(slots_factiveis[posicao])
        heuristica[estrela_chaves[slots_factiveis[posicao]][3]] = heuristica[estrela_chaves[slots_factiveis[posicao]][3]] + 1
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and slots_factiveis[posicao] in inequacoes[i][0]:
                inequacoes[i][1] = inequacoes[i][1] - 1
        c.remove(slots_factiveis[posicao])
        
        menor = 10000
        posicao = 0
        for j in range(len(slots_factiveis)):
            if heuristica[estrela_chaves[slots_factiveis[j]][3]] < menor:
                posicao = j
                menor = heuristica[estrela_chaves[slots_factiveis[j]][3]]
        lista_sorteados.append(slots_factiveis[posicao])
        # heuristica[posicao] = heuristica[posicao] + 1
        heuristica[estrela_chaves[slots_factiveis[posicao]][3]] = heuristica[estrela_chaves[slots_factiveis[posicao]][3]] + 1
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and slots_factiveis[posicao] in inequacoes[i][0]:
                inequacoes[i][1] = inequacoes[i][1] - 1
        c.remove(slots_factiveis[posicao])

    existe_valor = False
    for i in range(len(inequacoes)):
        if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
            existe_valor = True
            break
xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)
print('Heurística: ', heuristica)
'''
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
'''
vez = 0
temp = []
for i in range(len(inequacoes)):
    temp.append(inequacoes[i][1])
while vez < 50:
    for i in range(len(inequacoes)):
        inequacoes[i][1] = temp[i]
    prof_org = []
    for i in range(len(professores_objetos)):
        prof_org.append(i)
    prof_obj = []
    for i in range(len(prof_org)):
        sorteio = choice(prof_org)
        prof_obj.append(sorteio)  # professores embaralhados
        prof_org.remove(sorteio)
    # c = [571, 3506, 569, 5183, 6636, 3853, 2626, 6634, 5199, 2635, 3863, 6042, 3515, 4154, 2795, 6355, 12, 2777, 557, 6350, 18, 5189, 1423, 1416, 6047, 41, 6664, 2893, 1432, 6062, 3881, 2674, 1428, 34, 6376, 585, 6058, 3890, 6388, 2655, 6669, 4192, 2898, 3529, 3546, 5211, 5202, 5222, 575, 595, 5951, 3908, 4781, 2807, 3568, 3922, 2824, 5385, 3563, 5964, 65, 2267, 4221, 1509, 4775, 5603, 6402, 4212, 55, 4791, 6423, 5379, 5620, 2261, 5394, 2830, 4240, 5995, 4236, 3597, 4818, 2294, 5424, 3926, 1027, 3578, 5634, 92, 79, 2825, 3939, 5635, 4808, 5981, 2298, 5412, 5416, 6432, 6446, 4813, 4274, 3619, 614, 2856, 3610, 972, 2695, 2688, 3961, 1065, 2505, 2512, 6018, 957, 4258, 2867, 103, 6698, 1050, 3971, 6004, 616, 951, 6677, 609, 6459, 2700, 6130, 4829, 3996, 6468, 2723, 4839, 636, 2919, 5838, 3635, 4845, 1087, 649, 6141, 128, 4276, 3632, 3977, 631, 140, 1092, 2908, 5847, 653, 3663, 2742, 3650, 666, 659, 156, 152, 4010, 2729, 5873, 4311, 5868, 3374, 2039, 4020, 6165, 3357, 2044, 2926, 2947, 4871, 6158, 4862, 4855, 3689, 3422, 3677, 2959, 5442, 175, 5429, 5891, 4333, 5446, 3411, 2318, 2962, 185, 4878, 5674, 4344, 1532, 5656, 5895, 4026, 2305, 4898, 4890, 4038, 685, 5688, 3724, 1100, 5914, 4922, 4357, 6477, 6490, 4056, 3703, 2346, 201, 5683, 220, 4918, 4062, 5919, 692, 2341, 4373, 680, 2986, 2979, 4909, 704, 999, 6175, 3737, 242, 4091, 3007, 989, 6521, 4384, 6188, 3745, 977, 2755, 5936, 6501, 3015, 4083, 2760, 1131, 5928, 1144, 4397, 718, 723, 6595, 255, 1778, 4465, 4462, 268, 274, 1781, 4454, 5457, 5464, 2421, 792, 251, 6575, 3208, 785, 3222, 3219, 2411, 5452, 2416, 784, 6588, 798, 6612, 3248, 3235, 2434, 6714, 290, 4999, 803, 4988, 1818, 1811, 275, 820, 6706, 4991, 6607, 296, 6702, 3226, 283, 2442, 6604, 819, 805, 2447, 2056, 2071, 1161, 2052, 3267, 5001, 3760, 3757, 3774, 5491, 309, 3253, 837, 1169, 5018, 5480, 825, 5014, 313, 322, 304, 840, 833, 5498, 3270, 2085, 3793, 863, 328, 345, 6208, 5515, 1180, 5032, 2091, 1197, 5044, 3775, 5511, 5048, 6224, 6212, 2076, 342, 852, 3784, 5504, 871, 339, 856, 3302, 6117, 6107, 4501, 374, 1272, 6103, 4514, 887, 4520, 5544, 891, 360, 1263, 5548, 880, 4115, 3321, 4100, 356, 4111, 5534, 3308, 368, 879, 2147, 4549, 392, 4130, 4128, 376, 1298, 918, 907, 6734, 3331, 910, 3329, 4536, 4533, 921, 3341, 6725, 6738, 387, 2139, 4144, 1290, 395, 2127, 6267, 3822, 6261, 933, 407, 6253, 925, 416, 5551, 4565, 421, 948, 2163, 944, 4562, 2159, 402, 1305, 2174, 3818, 1304, 4556, 5560, 3814, 5570, 6289, 3842, 3849, 2175, 434, 6280, 436, 2198, 2181, 5593, 1020, 6294, 447, 4596, 5587, 5578, 4585, 1001, 4577, 1015, 1333, 3832, 1013, 1341, 429, 458, 457, 466, 1705, 1720, 451, 465, 459, 473, 474, 450, 462, 464, 463, 460, 452, 467, 453, 456, 472, 471, 468, 4766, 4758, 5310, 487, 5097, 5307, 5078, 6096, 1249, 5092, 6093, 5315, 4752, 3298, 3289, 481, 3280, 1226, 4761, 4488, 4484, 4475, 494, 6079, 5320, 5742, 5127, 6300, 4623, 2208, 6307, 5731, 1371, 4605, 5149, 5738, 511, 5137, 1360, 2220, 5328, 6322, 515, 5341, 5143, 4619, 2204, 501, 5334, 5339, 2242, 5770, 5373, 4628, 5750, 6333, 5164, 532, 6338, 1377, 1386, 4647, 5759, 543, 4641, 5362, 529, 5355, 2226, 5156, 5171, 5165, 2235, 6349, 5369, 5776, 1887, 742, 1881, 734, 747, 5791, 739, 5798, 745, 736, 729, 740, 744, 732, 725, 730, 743, 749, 746, 727, 735, 733, 728, 738, 1657, 755, 1672, 774, 761, 762, 765, 767, 759, 750, 760, 751, 771, 766, 768, 770, 773, 752, 763, 758, 756, 753, 5709, 1218, 5065, 5292, 5058, 5714, 5278, 1206, 5107, 5716, 3077, 5297, 3085, 6229, 2113, 2100, 6244, 5071, 5101, 2124, 5280, 5120, 6236, 5112, 3098, 3049, 1454, 2352, 6540, 6526, 4423, 4400, 1471, 2355, 5236, 3164, 3032, 3166, 4419, 6535, 3037, 5243, 5245, 3156, 2363, 4709, 4722, 4717, 5233, 4703, 5252, 3061, 3184, 1489, 4433, 4740, 3070, 2375, 3067, 6568, 6556, 3196, 4441, 2387, 2394, 4749, 4428, 3179, 4730, 4735, 5263, 5257, 1476, 5273, 6572, 3468, 1554, 1569, 3470, 3461, 3460, 3451, 3462, 3463, 3453, 3471, 3465, 3473, 3452, 3466, 3474, 3458, 3459, 3450, 3457, 3467, 3456, 1592, 1598, 2460, 2454, 2457, 2462, 2453, 2468, 2463, 2470, 2469, 2461, 2466, 2452, 2472, 2459, 2465, 2450, 2471, 2456, 2474, 2458, 1610, 4934, 1601, 4933, 4939, 4932, 4931, 4925, 4927, 4945, 4928, 4938, 4936, 4937, 4941, 4949, 4940, 4943, 4944, 4948, 4946, 4929, 1649, 1627, 2543, 2541, 1687, 2529, 2544, 2532, 1684, 2549, 2540, 2530, 2548, 2536, 2528, 2546, 2539, 2535, 2538, 2531, 2547, 2525, 2526, 2533, 4674, 1725, 4660, 4668, 4670, 3115, 4658, 3113, 4673, 4656, 4657, 4652, 4659, 4651, 4661, 4667, 4672, 1746, 4669, 4666, 3105, 4654, 4662, 4664, 4653, 2575, 2583, 2592, 2586, 2580, 2596, 1766, 2589, 3149, 2593, 2579, 3132, 2581, 1763, 2578, 2597, 2576, 2587, 3127, 2595, 2584, 2598, 2594, 2590, 2585, 4966, 1847, 1832, 4971, 4964, 4963, 4974, 4969, 4953, 4954, 4950, 4951, 4956, 4961, 4955, 4973, 4968, 4959, 4960, 4965, 4958, 4970, 2484, 1858, 1850, 2482, 2492, 2478, 2480, 2498, 2479, 2494, 2497, 2490, 2499, 2496, 2481, 2486, 2476, 2491, 2488, 2487, 2477, 2489, 3489, 5808, 3493, 1917, 3482, 3495, 3490, 1902, 5824, 3491, 3497, 5810, 3478, 3487, 3481, 3494, 3479, 3480, 3496, 3475, 3484, 3476, 3486, 3498, 3488, 1934, 1946, 1954, 1965, 2567, 2561, 2551, 2562, 2550, 2558, 2553, 2560, 2563, 2574, 2572, 2569, 2559, 2570, 2555, 2568, 2566, 2552, 2571, 2557, 4675, 1998, 4697, 3434, 4683, 4687, 4681, 4680, 3443, 4689, 4691, 4678, 4685, 4694, 4690, 4695, 4692, 4679, 3426, 4699, 1986, 4682, 4696, 4688, 4677, 2613, 3390, 2614, 3378, 2005, 3387, 2020, 2616, 2617, 2609, 2611, 2600, 2624, 2618, 2619, 2606, 2604, 2607, 2623, 2602, 2610, 2621, 2601, 2622, 2608]
    c = []
    lista_sorteados = []
    matriz_indices = []
    for i in range(len(turmas_objetos)):
        novo = []
        for j in range(len(slots_objetos)):
            novo.append([-1, -1])
        matriz_indices.append(novo)

    for prof_ind in prof_obj:
        for turma_ind in range(len(turmas_objetos)):
            for todos_ind in range(len(estrela_chaves)):
                if prof_ind == estrela_chaves[todos_ind][2] and turma_ind == estrela_chaves[todos_ind][0]:
                    c.append(todos_ind)

    for i in range(len(x)):
        c.append(i)
    vez = vez + 1
    print('Rodada: ', vez, 'Professores: ', prof_obj)
    existe_valor = True
    cont = 0
    while existe_valor and len(c) != 0:
        # valor_da_vez = choice(c)
        valor_da_vez = c[0]
        cont = cont + 1
        tem_7 = False
        tem_6 = False
        tem_4 = False
        tem_3 = False
        tem_2 = False
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '2':
                if valor_da_vez in inequacoes[i][0]:
                    tem_2 = True
                    break
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '3':
                if valor_da_vez in inequacoes[i][0]:
                    tem_3 = True
                    break
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '4':
                if valor_da_vez in inequacoes[i][0]:
                    tem_4 = True
                    break
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '6':
                if valor_da_vez in inequacoes[i][0]:
                    tem_6 = True
                    break
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
                if valor_da_vez in inequacoes[i][0]:
                    tem_7 = True
                    break
        if tem_2 and tem_3 and tem_6 and tem_7:
            lista_sorteados.append(valor_da_vez)
            turma = estrela_chaves[valor_da_vez][0]
            disc = estrela_chaves[valor_da_vez][1]
            prof = estrela_chaves[valor_da_vez][2]
            slot = estrela_chaves[valor_da_vez][3]
            matriz_indices[turma][slot] = [disc, prof]
            for i in range(len(inequacoes)):
                if inequacoes[i][1] > 0 and valor_da_vez in inequacoes[i][0]:
                    inequacoes[i][1] = inequacoes[i][1] - 1
            # c.remove(valor_da_vez)
        else:
            # avalia colisão slot
            pass
            if tem_2 and not tem_3 and tem_6 and tem_7:
                turma = estrela_chaves[valor_da_vez][0]
                slot = estrela_chaves[valor_da_vez][3]
                if matriz_indices[turma][slot][1] == -1:
                    # tem colisão
                    lista_professores_turma = matriz_indices[turma]
                    coluna_colisao = []
                    for i in range(len(matriz_indices)):
                        if matriz_indices[i][slot][1] > -1:
                            coluna_colisao.append(matriz_indices[i][slot][1])
                    for s in range(len(lista_professores_turma)):
                        if lista_professores_turma[s][1] > -1:
                            # coluna de interesse.
                            coluna_corrente = []
                            for i in range(len(turmas_objetos)):
                                coluna_corrente.append(matriz_indices[i][s][1])
                            if estrela_chaves[valor_da_vez][2] not in coluna_corrente and\
                                    lista_professores_turma[s][1] not in coluna_colisao:
                                # dá para trocar elementos.
                                for k in range(len(estrela_chaves)):
                                    if estrela_chaves[k][0] == turma and\
                                        estrela_chaves[k][1] == lista_professores_turma[s][0] and\
                                        estrela_chaves[k][2] == lista_professores_turma[s][1] and\
                                        estrela_chaves[k][3] == s:
                                        valor_org = k
                                for k in range(len(estrela_chaves)):
                                    if estrela_chaves[k][0] == turma and\
                                        estrela_chaves[k][1] == lista_professores_turma[s][0] and\
                                        estrela_chaves[k][2] == lista_professores_turma[s][1] and\
                                        estrela_chaves[k][3] == estrela_chaves[valor_da_vez][3]:
                                        valor_org_alt = k
                                for k in range(len(estrela_chaves)):
                                    if estrela_chaves[k][0] == estrela_chaves[valor_da_vez][0] and\
                                        estrela_chaves[k][1] == estrela_chaves[valor_da_vez][1] and\
                                        estrela_chaves[k][2] == estrela_chaves[valor_da_vez][2] and\
                                        estrela_chaves[k][3] == s:
                                        valor_da_vez_alt = k
                                lista_sorteados.remove(valor_org)
                                c.append(valor_org)
                                c.insert(0, valor_da_vez_alt)
                                matriz_indices[turma][s] = [-1, -1]
                                for i in range(len(inequacoes)):
                                    if valor_org in inequacoes[i][0]:
                                        inequacoes[i][1] = inequacoes[i][1] + 1
                                c.insert(0, valor_org_alt)
                                break
        c.remove(valor_da_vez)
        existe_valor = False
        for i in range(len(inequacoes)):
            if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
                existe_valor = True
                break
    xx = []
    for i in range(len(x)):
        if i in lista_sorteados:
            xx.append(1)
        else:
            xx.append(0)

    cont = 0
    for i in range(len(x)):
        if x[i].X == 1:
            cont = cont + 1
    print('Total de X: ', cont)

    cont = 0
    for i in range(len(xx)):
        if xx[i] == 1:
            cont = cont + 1
    print('Total de xx: ', cont)
    for i in range(len(turmas_objetos)):
        for ww in range(len(slots_objetos)):
            if ww == 24:
                matriz = str(matriz_indices[i][ww][1]) + '\t\t'
            else:
                matriz = str(matriz_indices[i][ww][1]) + '\t'
            print(matriz, end="")
        print()
    for i in range(len(professores_objetos)):
        cont = 0
        for ii in range(len(matriz_indices)):
            for ww in range(len(matriz_indices[ii])):
                if matriz_indices[ii][ww][1] == i:
                    cont = cont + 1
        print('Professor ', i, ': ', cont, '\t', end="")
    print('\n---------------------------------------------------------------')
'''
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
'''
print('Formando referências.')
turmas_backup = []
turmas_creditos = []
for i in range(len(turmas_objetos)):
    cred = 0
    turma_unica = []
    tuplas_td = []
    for j in range(len(estrela_chaves)):
        if estrela_chaves[j][0] == i:
            turma_unica.append(j)
            if [i, estrela_chaves[j][1]] not in tuplas_td:
                cred = cred + disciplinas_objetos[estrela_chaves[j][1]].quantidade_aulas_semanais
                tuplas_td.append([i, estrela_chaves[j][1]])
    turmas_backup.append(turma_unica)
    turmas_creditos.append(cred)
lista_sorteados = []
print('Começando alocação.')
for t in range(len(turmas_objetos)):
    print('\nTurma: ', t)
    vez = 1
    # print('Vez: ', vez)
    temp_sorteados = []
    temp_entradas = copy.deepcopy(turmas_backup[t])
    print('Tamanho entrada: ', turmas_creditos[t])
    temp_inequacoes = copy.deepcopy(inequacoes)
    nao_finalizado = True
    while nao_finalizado:
        valor_da_vez = choice(temp_entradas)
        tem_7 = False
        tem_6 = False
        tem_4 = False
        tem_3 = False
        tem_2 = False
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '2':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_2 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '3':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_3 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '4':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_4 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '6':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_6 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '7':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_7 = True
                    break
        if tem_2 and tem_3 and tem_4 and tem_6 and tem_7:
            temp_sorteados.append(valor_da_vez)
            temp_entradas.remove(valor_da_vez)
            for i in range(len(temp_inequacoes)):
                if temp_inequacoes[i][1] > 0 and valor_da_vez in temp_inequacoes[i][0]:
                    temp_inequacoes[i][1] = temp_inequacoes[i][1] - 1
        else:
            temp_entradas.remove(valor_da_vez)

        if len(temp_entradas) == 0:
            if len(temp_sorteados) == turmas_creditos[t]:
                for i in range(len(temp_sorteados)):
                    lista_sorteados.append(temp_sorteados[i])
                inequacoes = copy.deepcopy(temp_inequacoes)
                nao_finalizado = False
                print('Vezes: -----------------------------', vez)
            else:
                vez = vez + 1
                temp_sorteados = []
                temp_entradas = copy.deepcopy(turmas_backup[t])
                temp_inequacoes = copy.deepcopy(inequacoes)
                nao_finalizado = True

xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
'''
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# Encaixando peças
'''
for i in range(6750):
    total = 0
    for j in range(len(inequacoes)):
        if i in inequacoes[j][0]:
            total = total + 1
            if i > 0 and i < 50:
                print(inequacoes[j])
    print('i: ', i, 'total: ', total)

for i in range(6750):
    total_2 = 0
    total_3 = 0
    total_4 = 0
    total_6 = 0
    total_7 = 0
    min = 100
    max = -100
    for j in range(len(inequacoes)):
        if i in inequacoes[j][0]:
            if inequacoes[j][2] == '3':
                total_3 = total_3 + 1
    print('i: ', i, 'total_3: ', total_3)
    if total_3 < min:
        min = total_3
    if total_3 > max:
        max = total_3
    # if total_3 != 1:
    # print('99999999999999')
print('min: ', min)
print('max: ', max)

iteracoes = 0
tempo_1 = time.time()
print('Formando referências.')
turmas_backup = []
turmas_creditos = []
for i in range(len(turmas_objetos)):
    cred = 0
    turma_unica = []
    tuplas_td = []
    for j in range(len(estrela_chaves)):
        if estrela_chaves[j][0] == i:
            turma_unica.append(j)
            if [i, estrela_chaves[j][1]] not in tuplas_td:
                cred = cred + disciplinas_objetos[estrela_chaves[j][1]].quantidade_aulas_semanais
                tuplas_td.append([i, estrela_chaves[j][1]])
    turmas_backup.append(turma_unica)
    turmas_creditos.append(cred)
lista_sorteados = []
print('Começando alocação.')
for t in range(len(turmas_objetos)):
    print('\nTurma: ', t)
    vez = 1
    # print('Vez: ', vez)
    temp_sorteados = []
    temp_entradas = copy.deepcopy(turmas_backup[t])
    print('Tamanho entrada: ', turmas_creditos[t])
    temp_inequacoes = copy.deepcopy(inequacoes)
    nao_finalizado = True
    while nao_finalizado:
        valor_da_vez = choice(temp_entradas)
        tem_7 = False
        tem_6 = False
        tem_4 = False
        tem_3 = False
        tem_2 = False
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '2':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_2 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '3':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_3 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '4':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_4 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '6':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_6 = True
                    break
        for i in range(len(temp_inequacoes)):
            if temp_inequacoes[i][1] > 0 and temp_inequacoes[i][2] == '7':
                if valor_da_vez in temp_inequacoes[i][0]:
                    tem_7 = True
                    break
        if tem_2 and tem_3 and tem_4 and tem_6 and tem_7:
            temp_sorteados.append(valor_da_vez)
            temp_entradas.remove(valor_da_vez)
            for i in range(len(temp_inequacoes)):
                if temp_inequacoes[i][1] > 0 and valor_da_vez in temp_inequacoes[i][0]:
                    temp_inequacoes[i][1] = temp_inequacoes[i][1] - 1
        else:
            temp_entradas.remove(valor_da_vez)
        if len(temp_sorteados) == turmas_creditos[t]:
            temp_entradas = []
        if len(temp_entradas) == 0:
            if len(temp_sorteados) == turmas_creditos[t]:
                for i in range(len(temp_sorteados)):
                    lista_sorteados.append(temp_sorteados[i])
                inequacoes = copy.deepcopy(temp_inequacoes)
                nao_finalizado = False
                print('Vezes: -----------------------------', vez)
                iteracoes = iteracoes + vez
            else:
                vez = vez + 1
                temp_sorteados = []
                temp_entradas = copy.deepcopy(turmas_backup[t])
                temp_inequacoes = copy.deepcopy(inequacoes)
                nao_finalizado = True
xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
tempo_2 = time.time()
intervalo = (tempo_2 - tempo_1)/60
print(iteracoes, ' iterações.')
print(intervalo, ' minutos.')
'''
# --------------------------------------------------------------------------------------------------------
lista_tdps = []
lista_d = []
lista_p = []
lista_s = []
for t in range(len(turmas_objetos)):
    for d in range(len(disciplinas_objetos)):
        for p in range(len(professores_objetos)):
            for s in range(len(slots_objetos)):
                lista_s.append(99999)
            lista_p.append(lista_s)
            lista_s = []
        lista_d.append(lista_p)
        lista_p = []
    lista_tdps.append(lista_d)
    lista_d = []
# --------------------------------------------------------------------------------------------------------
class Individuo:
    def __init__(self, individuo):
        self.individuo = individuo
        self.solucao = []

    def individuo(self):
        return self.individuo

    def testa_solucao(self, inequacoes, lista_tdps):
        for s in range(len(self.individuo)):
            if self.individuo[s] != 0:
                t = self.individuo[s][0]
                d = self.individuo[s][1]
                p = self.individuo[s][2]
                valor_da_vez = lista_tdps[t][d][p][s]
                tem_7 = False
                tem_6 = False
                tem_4 = False
                tem_3 = False
                tem_2 = False
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and inequacoes[i][2] == '2':
                        if valor_da_vez in inequacoes[i][0]:
                            tem_2 = True
                            break
                        else:
                            return False
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and inequacoes[i][2] == '3':
                        if valor_da_vez in inequacoes[i][0]:
                            tem_3 = True
                            break
                        else:
                            return False
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and inequacoes[i][2] == '4':
                        if valor_da_vez in inequacoes[i][0]:
                            tem_4 = True
                            break
                        else:
                            return False
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and inequacoes[i][2] == '6':
                        if valor_da_vez in inequacoes[i][0]:
                            tem_6 = True
                            break
                        else:
                            return False
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and inequacoes[i][2] == '7':
                        if valor_da_vez in inequacoes[i][0]:
                            tem_7 = True
                            break
                        else:
                            return False
                # limpar inequações
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and valor_da_vez in inequacoes[i][0]:
                        inequacoes[i][1] = inequacoes[i][1] - 1
        for s in range(len(self.individuo)):
            if self.individuo[s] != 0:
                t = self.individuo[s][0]
                d = self.individuo[s][1]
                p = self.individuo[s][2]
                valor_da_vez = lista_tdps[t][d][p][s]
                self.solucao.append(valor_da_vez)
        return True

    def solucao_frame(self):
        return self.solucao

    def fitness(self, inequacoes, lista_tdps):
        print(inequacoes)
        fitness = 0
        for s in range(frame_tamanho):
            if self.individuo[s] != 0:
                t = self.individuo[s][0]
                d = self.individuo[s][1]
                p = self.individuo[s][2]
                valor_da_vez = lista_tdps[t][d][p][s]
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and inequacoes[i][2] == '3':
                        if valor_da_vez in inequacoes[i][0]:
                            fitness = fitness + 1
                for i in range(len(inequacoes)):
                    if inequacoes[i][1] > 0 and inequacoes[i][2] == '4':
                        if valor_da_vez in inequacoes[i][0]:
                            fitness = fitness + 1
            return fitness
# --------------------------------------------------------------------------------------------------------
# Testes de heurística:
# Encaixando peças
# Aqui neste bloco será aplicado um algoritmo genético.
iteracoes = 0
tempo_1 = time.time()
turmas_backup = []
turmas_creditos = []
range_100 = []
for i in range(1, 101):
    range_100.append(i)
frame_tamanho = 25
range_25 = []
for i in range(frame_tamanho):
    range_25.append(i)
for i in range(len(turmas_objetos)):
    # N_individuos representa o número de indivíduos deste algoritmo genético
    frame_turno = ''
    frame_tuplas_tdp = []
    cred = 0
    for j in range(len(estrela_chaves)):
        tu = estrela_chaves[j][0]
        if tu == i:
            di = estrela_chaves[j][1]
            pr = estrela_chaves[j][2]
            if [tu, di, pr] not in frame_tuplas_tdp:
                cr = disciplinas_objetos[di].quantidade_aulas_semanais
                for w in range(cr):
                    frame_tuplas_tdp.append([tu, di, pr])
                    cred = cred + cr
    if len(frame_tuplas_tdp) < frame_tamanho:
        falta = frame_tamanho - len(frame_tuplas_tdp)
        for k in range(falta):
            frame_tuplas_tdp.append(0)
    turmas_backup.append(frame_tuplas_tdp)
    turmas_creditos.append(cred)
lista_sorteados = []
for t in range(len(turmas_objetos)):
    n_individuos = 20
    individuos = []  # n indivíduos (cada indivíduo, um frame)
    print('\nTurma: ', t)
    vez = 1
    # print('Vez: ', vez)
    temp_sorteados = []
    temp_entradas = copy.deepcopy(turmas_backup[t])
    temp_inequacoes = copy.deepcopy(inequacoes)
    print('Tamanho entrada: ', turmas_creditos[t])
    populacao_atual = []
    temp = copy.deepcopy(turmas_backup[t])
    print('temp: ', temp)
    for i in range(n_individuos):
        shuffle(temp)
        populacao_atual.append(Individuo(copy.deepcopy(temp)))
    # populações convergem aqui.
    finalizado = False
    while not finalizado:
        individuo_fitness = []
        for i in range(len(populacao_atual)):
            individuo_fitness.append(populacao_atual[i].fitness(temp_inequacoes, lista_tdps))
        print('Individuo_fitness: ', individuo_fitness)
        # Aqui começa a seleção
        # Para selecionar é preciso transformar o valor de fitness em uma escala de 0-10000.
        total = 0
        for i in range(n_individuos):
            total = total + individuo_fitness[i]
        print('total: ', total)
        roleta_range = []
        for i in range(n_individuos):
            if i == 0:
                inicio = 0
            else:
                inicio = roleta_range[i-1][1]
            fim = inicio + (individuo_fitness[i] * 10000 / total)
            roleta_range.append([inicio, fim])
        selecionados = []
        for i in range(n_individuos):
            valor = random.randomint(0,10001)
            for j in range(n_individuos):
                if roleta_range[j][0] <= valor and valor <= roleta_range[j][1]:
                    selecionados.append(populacao_atual[i])
        # Neste ponto temos os selecionados.
        lista_crossover = []
        nao_lista_crossover = []
        pc = 70
        for i in range(len(selecionados)):
            valor = choice(range_100)
            if valor <= pc:
                lista_crossover.append(selecionados[i])
            else:
                nao_lista_crossover.append(selecionados[i])
        # Verificar se número ímpar de selecionados:
        if len(lista_crossover)%2 == 0:
            pass
        else:
            tamanho_lista = len(lista_crossover)
            indice = tamanho_lista - 1
            valor = lista_crossover[indice]
            nao_lista_crossover.append(valor)
            lista_crossover.pop(indice)
        # Realizar crossover (position-based crossover)
        # Critério: trocar o conteúdo de 5 posições e manter as outras
        # Então vamos sortear as 5 posições que serão embaralhadas
        range_5 = []
        while len(range_5) != 5:
            sorte = random.randomint(0,frame_tamanho + 1)
            if sorte not in range_5:
                range_5.append(sorte)
        # Vamos gerar os filhos.
        filhos = []
        for i in range(lista_crossover):
            filho = []
            posicao_nova = []
            for j in range(len(range_5)):
                posicao_nova.append(lista_crossover[range_5[j]])
            shuffle(posicao_nova)
            for j in range(frame_tamanho):
                if j in range_5:
                    filho.append(posicao_nova[0])
                    posicao_nova.remove(0)
                else:
                    filho.append(lista_crossover[i][j])
            filhos.append(filho)
        # Realizar mutação (order-based mutation).
        # Varrer posições e aplicar Bernoulli (pm)
        # Se posição for sofrer mutação, sortear outra posição para realizar a troca
        for i in range(len(filhos)):
            for j in range(len(frame_tamanho)):
                pm = 1
                valor = choice(range_100)
                if valor <= pm:
                    temp = filhos[i][j]
                    dest = choice(range_25)
                    filhos[i][j] = filhos[i][dest]
                    filhos[i][dest] = temp
        # Agora junta filhos e não escolhidos
        populacao_atual = []
        for i in range(len(filhos)):
            populacao_atual.append(filhos[i])
        for i in range(len(nao_lista_crossover)):
            populacao_atual.append(nao_lista_crossover[i])
        # Agora é testar se algum indivíduo é resultado válido.
        finalizado = False
        for i in range(len(populacao_atual)):
            tem_solucao = populacao_atual[i].testa_solucao()
            if tem_solucao:
                finalizado = True
                solucao = populacao_atual[i].solucao_frame()
                break
        if finalizado:
            for i in range(len(solucao)):
                lista_sorteados.append(solucao[i])
                for j in range(len(temp_inequacoes)):
                    if temp_inequacoes[j][1] > 0 and solucao[i] in temp_inequacoes[j][0]:
                        temp_inequacoes[j][1] = temp_inequacoes[j][1] - 1
                inequacoes = copy.deepcopy(temp_inequacoes)
            finalizado = True
            print('Vezes: -----------------------------', vez)
            iteracoes = iteracoes + vez

        else:
            vez = vez + 1
            temp_sorteados = []
            temp_entradas = copy.deepcopy(turmas_backup[t])
            temp_inequacoes = copy.deepcopy(inequacoes)
            finalizado = False

xx = []
for i in range(len(x)):
    if i in lista_sorteados:
        xx.append(1)
    else:
        xx.append(0)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
tempo_2 = time.time()
intervalo = (tempo_2 - tempo_1) / 60
print(iteracoes, ' iterações.')
print(intervalo, ' minutos.')

# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):
'''
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        # if x[tdps_lista[i]].X == 1:
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "\n\nTurma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma)\
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Professor(a) - heurística: ', professores_objetos[p].nome_professor)
    print(apresentacao)

t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        # if x[tdps_lista[i]].X == 1:
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "\n\nDisciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma - heurística: ', turmas_objetos[t].numero_turma)
    print(apresentacao)
'''
'''
cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)
print(lista_sorteados)
'''
# --------------------------------------------------------------------------------------------------------
