import gurobipy as gp
import pandas as pd
import copy
import sys
from prettytable import PrettyTable
from random import choice

START_POINT = 0
END_POINT = None

# Leitura completa da tabela fornecida
print('Realizando o processo de Leitura.')
df = pd.read_excel('./arquivo_ProjetoUFSC_v1.ods', engine='odf')
df['Código da disc. '] = df['Código da disc. '].astype(str)
# print(df.dtypes)
# print()
# print(df.info())


class Turma:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, tipo_turma,
                 codigo_turno, turno, codigo_area_ensino, area_ensino, tipo_grade):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma  # PK
        self.tipo_turma = tipo_turma
        self.codigo_turno = codigo_turno
        self.turno = turno
        self.codigo_area_ensino = codigo_area_ensino
        self.area_ensino = area_ensino
        self.tipo_grade = tipo_grade

    def numero_turma(self):
        return self.numero_turma


class Disciplina:
    def __init__(self, matriz_curricular, etapa_serie, numero_turma, codigo_disciplina,
                 nome_disciplina, quantidade_aulas_semanais, codigo_area_ensino, area_ensino):
        self.matriz_curricular = matriz_curricular
        self.etapa_serie = etapa_serie
        self.numero_turma = numero_turma  # PK
        self.codigo_disciplina = codigo_disciplina  # PK
        self.nome_disciplina = nome_disciplina
        self.quantidade_aulas_semanais = quantidade_aulas_semanais
        self.codigo_area_ensino = codigo_area_ensino  # PK
        self.area_ensino = area_ensino

    def numero_turma(self):
        return self.numero_turma

    def codigo_disciplina(self):
        return self.codigo_disciplina

    def codigo_area_ensino(self):
        return self.codigo_area_ensino

    def quantidade_aulas_semanais(self):
        return self.quantidade_aulas_semanais


class Professor:
    def __init__(self, id_professor, cpf_professor, nome_professor):
        self.id_professor = id_professor
        self.cpf_professor = cpf_professor  # PK
        self.nome_professor = nome_professor

    def cpf_professor(self):
        return self.cpf_professor

    def nome_professor(self):
        return self.nome_professor


class Grade:
    def __init__(self, tipo_grade, turno):
        self.tipo_grade = tipo_grade
        self.turno = turno

    def grade_elementos(self):
        if self.tipo_grade == '1':
            if self.turno == 'todos':
                return ['1', ..., '51']
            else:
                if self.turno == 'Matutino':
                    return ['0', '1', '2', '3', '4', '11', '12', '13', '14',
                            '15', '22', '23', '24', '25', '26', '33', '34',
                            '35', '36', '37', '44', '45', '46', '47', '48']
                else:
                    if self.turno == 'Vespertino':
                        return ['5', '6', '7', '8', '9', '16', '17', '18',
                                '19', '20', '27', '28', '29', '30', '31', '38',
                                '39', '40', '41', '42', '49', '50', '51', '52', '53']
                    else:
                        return ['10', '21', '32', '43', '54']
        '''
        else:
            if self.tipo_grade == '2':
        '''
        return None

    def janelas(self):
        return [['0', '1', '2'], ['1', '2', '3'], ['2', '3', '4'],
                ['5', '6', '7'], ['6', '7', '8'], ['7', '8', '9'],
                ['11', '12', '13'], ['12', '13', '14'], ['13', '14', '15'],
                ['16', '17', '18'], ['17', '18', '19'], ['18', '19', '20'],
                ['22', '23', '24'], ['23', '24', '25'], ['24', '25', '26'],
                ['27', '28', '29'], ['28', '29', '30'], ['29', '30', '31'],
                ['33', '34', '35'], ['34', '35', '36'], ['35', '36', '37'],
                ['38', '39', '40'], ['39', '40', '41'], ['40', '41', '42'],
                ['44', '45', '46'], ['45', '46', '47'], ['46', '47', '48'],
                ['49', '50', '51'], ['50', '51', '52'], ['51', '52', '53']]

    def grade_vazia(self):
        lista = [['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['', '', '', '', ''],
                ['*****', '*****', '*****', '*****', '*****'],
                ['', '', '', '', '']]
        return lista

    def dias_semana(self):
        lista_ds = [['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
                    ['11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21'],
                    ['22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32'],
                    ['33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43'],
                    ['44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54']]
        return lista_ds

    def cabecalho(self):
        return ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta']

    def converte_slot_lc(self, slot):
        lista_lc = [[0, 0], [1, 0], [2, 0], [3,0], [4, 0], [6, 0],[7, 0], [8, 0], [9, 0], [10,0], [12, 0],
                    [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [6, 1], [7, 1], [8, 1], [9, 1], [10, 1], [12, 1],
                    [0, 2], [1, 2], [2, 2], [3, 2], [4, 2], [6, 2], [7, 2], [8, 2], [9, 2], [10, 2], [12, 2],
                    [0, 3], [1, 3], [2, 3], [3, 3], [4, 3], [6, 3], [7, 3], [8, 3], [9, 3], [10, 3], [12, 3],
                    [0, 4], [1, 4], [2, 4], [3, 4], [4, 4], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [12, 4]]
        return lista_lc[slot][0], lista_lc[slot][1]


class Slot:
    def __init__(self, slot):
        self._slot = slot

    @property
    def slot(self):
        return self._slot

    @slot.setter
    def slot(self, slot_novo):
        self.slot = slot_novo


class GrupoDisciplinas:
    def __init__(self, tipo_grupo, disciplinas):
        self.tipo_grupo = tipo_grupo
        self.disciplinas = disciplinas


# leitura dataframe escola e criação dos objetos correspondentes:
turmas_objetos = []
disciplinas_objetos = []
professores_objetos = []
slots_objetos = []

turmas_ponteiro = 0
disciplinas_ponteiro = 0
professores_ponteiro = 0
slots_ponteiro = 0
estrela_chaves = []

turma_prov = []
disciplina_prov = []
professor_prov = []
slot_prov = []

controle = []

for index, row in df.iterrows():
    # print(row)
    if row['Código da disc. '] != '611' and row['Código da disc. '] != '1344':
        controle.clear()
        turma_prov.clear()
        disciplina_prov.clear()
        professor_prov.clear()

        turma_prov = [row['Matriz curricular'],
                      row['Etapa (séries)'],
                      row['Número da turma'],
                      row['Tipo de turma (prov. não usaremos)'],
                      row['Cod. Turno'],
                      row['Turno'],
                      row['Código da área de ensino'],
                      row['Área de ensino'], '1']
        disciplina_prov = [row['Matriz curricular'],
                           row['Etapa (séries)'],
                           row['Número da turma'],
                           row['Código da disc. '],
                           row['Nome da disc. '],
                           row['Qtd de aulas na semana'],
                           row['Código da área de ensino'],
                           row['Área de ensino']]
        professor_prov = [row['Identificador do prof. '],
                          row['CPF'],
                          row['Nome']]
        grade = Grade('1', turma_prov[5])
        slot_prov = grade.grade_elementos()

        in_turma = False
        indice = 0
        if len(turmas_objetos) > 0:
            for objeto in turmas_objetos:
                if turma_prov[2] == objeto.numero_turma:
                    in_turma = True
                    break
                indice = indice + 1
        if in_turma:
            controle.append(indice)
        else:
            controle.append(turmas_ponteiro)
            turmas_objetos.append(Turma(turma_prov[0], turma_prov[1], turma_prov[2],
                                        turma_prov[3], turma_prov[4], turma_prov[5],
                                        turma_prov[6], turma_prov[7], turma_prov[8]))
            turmas_ponteiro = turmas_ponteiro + 1

        in_disciplina = False
        indice = 0
        if len(disciplinas_objetos) > 0:
            for objeto in disciplinas_objetos:
                if disciplina_prov[3] == objeto.codigo_disciplina \
                        and disciplina_prov[6] == objeto.codigo_area_ensino \
                        and disciplina_prov[1] == objeto.etapa_serie:
                    in_disciplina = True
                    break
                indice = indice + 1
        if in_disciplina:
            controle.append(indice)
        else:
            controle.append(disciplinas_ponteiro)
            disciplinas_objetos.append(Disciplina(disciplina_prov[0], disciplina_prov[1], disciplina_prov[2],
                                                  disciplina_prov[3], disciplina_prov[4], disciplina_prov[5],
                                                  disciplina_prov[6], turma_prov[7]))
            disciplinas_ponteiro = disciplinas_ponteiro + 1

        in_professor = False
        indice = 0
        if len(professores_objetos) > 0:
            for objeto in professores_objetos:
                if professor_prov[1] == objeto.cpf_professor:
                    in_professor = True
                    break
                indice = indice + 1
        if in_professor:
            controle.append(indice)
        else:
            controle.append(professores_ponteiro)
            professores_objetos.append(Professor(professor_prov[0], professor_prov[1], professor_prov[2]))
            professores_ponteiro = professores_ponteiro + 1

        # # print('slot_prov: ', slot_prov)
        for slots in slot_prov:
            in_slot = False
            indice = 0
            if len(slots_objetos) > 0:
                for objeto in slots_objetos:
                    if slots == objeto.slot:
                        in_slot = True
                        break
                    indice = indice + 1
            if in_slot:
                # controle.append(indice)
                # print('indice: ', indice)
                lista = [controle[0], controle[1], controle[2], indice]
                if lista not in estrela_chaves:
                    estrela_chaves.append(lista)
            else:
                # controle.append(slots_ponteiro)
                # print('slots_ponteiro: ', slots_ponteiro)
                lista = [controle[0], controle[1], controle[2], slots_ponteiro]
                if lista not in estrela_chaves:
                    # #print('Lista: ', lista)
                    estrela_chaves.append(lista)
                    slots_objetos.append(Slot(slots))
                    slots_ponteiro = slots_ponteiro + 1
# #print(estrela_chaves)
'''
for i in range(len(estrela_chaves)):
    print(turmas_objetos[estrela_chaves[i][0]].numero_turma,
          disciplinas_objetos[estrela_chaves[i][1]].codigo_disciplina,
          professores_objetos[estrela_chaves[i][2]].nome_professor,
          slots_objetos[estrela_chaves[i][3]].slot)
'''
print(len(estrela_chaves))
print(len(turmas_objetos))
print(len(disciplinas_objetos))
print(len(professores_objetos))
print(len(slots_objetos))

# [18/01/2023]
# Nesta parte do programa serão introduzidas as regras referentes à pesquisa operacional.
# 1) Variáveis do problema de Timetabling.
#
#      As listas "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos" são compostas
#      por objetos exclusivos, o que significa que, por exemplo, "turmas_objetos" possui todas as turmas da escola
#      que está sendo considerada.
#      Já a lista "estrela_chaves" possui todas as combinações possíveis para os elementos das listas
#      "turmas_objetos", disciplinas_objetos", "professores_objetos" e "slots_objetos". A estas combinações
#      serão consideradas variáveis para a esolução do problema.
#      Considerar X[t, d, p, s] como sendo a variável de interesse.

# Em uma avaliação preliminar do arquivo que temos em mãos, existem 7.525 combinações válidas t, d, p, s.
# T: 41 turmas
# D: 26 disciplinas
# P: 52 professores
# S: 50 slots

model = gp.Model("Timetabling")
# Variáveis da Pesquisa Operacional:
x_tdps = [i for i in range(len(estrela_chaves))]
x = model.addVars(x_tdps, vtype=gp.GRB.BINARY)
# Criação das variáveis Y:
pj = []  # tuplas professor-janela [p, s]
cont_pj = 0
buffer_s = []  # tdps associado a cada slot
s0 = []
s1 = []
s2 = []
somas = []
for i in range(len(slots_objetos)):
    buffer_s.append([])
for i in range(len(estrela_chaves)):
    estrela_chaves[i].append(i)
    buffer_s[estrela_chaves[i][3]].append(estrela_chaves[i])
grade = Grade('1', 'Matutino')
janelas = grade.janelas()
cont_ypj = 0
for professor in range(len(professores_objetos)):
    for jan in janelas:  # tuplas (s0, s1, s2)
        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[0] == slots_objetos[indice].slot:
                pos_s0 = indice
                obj_existe = True
                break
        if not obj_existe:
            break

        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[1] == slots_objetos[indice].slot:
                pos_s1 = indice
                obj_existe = True
                break
        if not obj_existe:
            break

        obj_existe = False
        for indice in range(len(slots_objetos)):
            if jan[2] == slots_objetos[indice].slot:
                pos_s2 = indice
                obj_existe = True
                break
        if not obj_existe:
            break

        s0.clear()
        s1.clear()
        s2.clear()
        s0_existe = False
        s1_existe = False
        s2_existe = False
        # print('buffer_s[0]: ', buffer_s[0])
        for i in range(len(buffer_s[pos_s0])):
            if professor == buffer_s[pos_s0][i][2]:
                s0.append(buffer_s[pos_s0][i][4])
                s0_existe = True
        for i in range(len(buffer_s[pos_s1])):
            if professor == buffer_s[pos_s1][i][2]:
                s1.append(buffer_s[pos_s1][i][4])
                s1_existe = True
        for i in range(len(buffer_s[pos_s2])):
            if professor == buffer_s[pos_s2][i][2]:
                s2.append(buffer_s[pos_s2][i][4])
                s2_existe = True
        if s0_existe and s1_existe and s2_existe:
            somas.append([copy.deepcopy(s0), copy.deepcopy(s1), copy.deepcopy(s2)])
            pj.append([professor, jan])
            # print('pj: ', pj)
            # print('somas: ', somas)
            # print()
            cont_pj = cont_pj + 1

y_pj = [i for i in range(len(pj))]
y = model.addVars(y_pj, vtype=gp.GRB.BINARY)
tolerancia = 0.0001
# print(somas)
for cont in range(len(somas)):
    # print('somas: ', somas[cont][0])
    # print('somas: ', somas[cont][1])
    # print('somas: ', somas[cont][2])
    # print(x)
    # print(y)
    # print('len(somas[cont][0])): ', len(somas[cont][0]))
    '''
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) + 6 >= (9 * y[cont]==1 +
                                                                                                      tolerancia),
    '''
    eps = 0.0001
    M = 10 + eps    # smallest possible given bounds on x and y

    # Model if x > y, then b = 1, otherwise b = 0
    # m.addConstr(x >= y + eps - M * (1 - b), name="bigM_constr1")
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) >= 3 + eps\
                    - M * (1 - y[cont]), name="RESTRIÇÃO janelas >: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))
    # m.addConstr(x <= y + M * b, name="bigM_constr2")
    model.addConstr(2 * gp.quicksum(x[somas[cont][0][c1]] for c1 in range(len(somas[cont][0])))
                     -2 * gp.quicksum(x[somas[cont][1][c2]] for c2 in range(len(somas[cont][1])))
                     + 2 * gp.quicksum(x[somas[cont][2][c3]] for c3 in range(len(somas[cont][2]))) <= 3\
                    + M * y[cont], name="RESTRIÇÃO janelas <: p_" + str(pj[cont][0]) + " j_" + str(pj[cont][1]))
# --------------------------------------------------------------------------------------------------------
# Função Objetivo da Pesquisa Operacional:
model.setObjective(gp.quicksum(y[i] for i in range(len(y_pj))), sense=gp.GRB.MINIMIZE)
# --------------------------------------------------------------------------------------------------------
# Restrições da Pesquisa Operacional:
inequacoes = []

# RESTRIÇÃO 2:
ts_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][3]] not in ts_lista:
        ts_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][3]])
tdps_lista = []
for ts in ts_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][3]] == ts:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1, "RESTRIÇÃO 2: t_" + str(ts[0]) + " s_" + str(ts[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1])

# RESTRIÇÃO 3:
ps_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][2], estrela_chaves[cont][3]] not in ps_lista:
        ps_lista.append([estrela_chaves[cont][2], estrela_chaves[cont][3]])
tdps_lista = []
for ps in ps_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][2], estrela_chaves[cont][3]] == ps:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <= 1,
                        "RESTRIÇÃO 3: p_" + str(ps[0]) + " s_" + str(ps[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), 1])

# RESTRIÇÃO 4:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
grade = Grade('1', 'Matutino')
ds_lista = grade.dias_semana()
dias = grade.cabecalho()
for i in range(5):
    lista_um_ds = ds_lista[i]
    for td in td_lista:
        tdps_lista.clear()
        for cont in range(len(estrela_chaves)):
            if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
                if disciplinas_objetos[estrela_chaves[cont][1]].quantidade_aulas_semanais <= 5:
                    if slots_objetos[estrela_chaves[cont][3]].slot in lista_um_ds:
                        tdps_lista.append(cont)
        if len(tdps_lista) > 0:
            model.addConstr(gp.quicksum(x[i] for i in tdps_lista) <=1,
                            "RESTRIÇÃO 4: t_" + str(td[0]) + " d_" + str(td[1]) + " ds_" + dias[i])
            inequacoes.append([copy.deepcopy(tdps_lista), 1])

# RESTRIÇÃO 6:
p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
lista_disc = []
teste = 0
for p in p_lista:
    # print('p: ', p)
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    # print('tdps_lista: ', tdps_lista)
    lista_disc.clear()
    for i in range(len(tdps_lista)):
        if [estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]] not in lista_disc:
            lista_disc.append([estrela_chaves[tdps_lista[i]][0], estrela_chaves[tdps_lista[i]][1]])
    soma = 0
    # print('disc: ', lista_disc)
    for i in range(len(lista_disc)):
        soma = soma + disciplinas_objetos[lista_disc[i][1]].quantidade_aulas_semanais
        # print('parcela: ', disciplinas_objetos[lista_disc[i][1]].quantidade_aulas_semanais)
        # print(soma)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) == soma, "RESTRIÇÃO 6: p_" + str(p))
        inequacoes.append([copy.deepcopy(tdps_lista), soma])


# RESTRIÇÃO 7:
td_lista = []
for cont in range(len(estrela_chaves)):
    if [estrela_chaves[cont][0], estrela_chaves[cont][1]] not in td_lista:
        td_lista.append([estrela_chaves[cont][0], estrela_chaves[cont][1]])
tdps_lista = []
for td in td_lista:
    tdps_lista.clear()
    for cont in range(len(estrela_chaves)):
        if [estrela_chaves[cont][0], estrela_chaves[cont][1]] == td:
            tdps_lista.append(cont)
    if len(tdps_lista) > 0:
        model.addConstr(gp.quicksum(x[i] for i in tdps_lista) == disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]]\
                        .quantidade_aulas_semanais, "RESTRIÇÃO 7: t_" + str(td[0]) + " d_" + str(td[1]))
        inequacoes.append([copy.deepcopy(tdps_lista), disciplinas_objetos[estrela_chaves[tdps_lista[0]][1]]\
                        .quantidade_aulas_semanais])

# --------------------------------------------------------------------------------------------------------
# Execução da modelagem:

model.optimize()
# print(model.display())

'''
print(len(x))
print(len(y))
print(x)
for i in range(len(x)):
    print('x[', i, '] = ', x[i].X)
'''
# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):

p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        if x[tdps_lista[i]].X == 1:
        # if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "Turma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma)\
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)\
                + "\n" + "C: " + x[tdps_lista[i]].varName
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Professor(a): ', professores_objetos[p].nome_professor)
    print(apresentacao)

t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        if x[tdps_lista[i]].X == 1:
        # if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma: ', turmas_objetos[t].numero_turma)
    print(apresentacao)

# --------------------------------------------------------------------------------------------------------
'''
# Recorrência se resultado for Unfeasible:

# model.write("model.ilp")

# From "https://www.gurobi.com/documentation/10.0/examples/workforce2_py.html#subsubsection:workforce2.py":
status = model.Status
if status == gp.GRB.UNBOUNDED:
    print('The model cannot be solved because it is unbounded')
    sys.exit(0)
if status == gp.GRB.OPTIMAL:
    print('The optimal objective is %g' % model.ObjVal)
    sys.exit(0)
if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
    print('Optimization was stopped with status %d' % status)
    sys.exit(0)

# do IIS
print('The model is infeasible; computing IIS')
removed = []

# Loop until we reduce to a model that can be solved
while True:

    model.computeIIS()
    print('\nThe following constraint cannot be satisfied:')
    for c in model.getConstrs():
        if c.IISConstr:
            print('%s' % c.ConstrName)
            # Remove a single constraint from the model
            removed.append(str(c.ConstrName))
            model.remove(c)
            break
    print('')

    model.optimize()
    status = model.Status

    if status == gp.GRB.UNBOUNDED:
        print('The model cannot be solved because it is unbounded')
        sys.exit(0)
    if status == gp.GRB.OPTIMAL:
        break
    if status != gp.GRB.INF_OR_UNBD and status != gp.GRB.INFEASIBLE:
        print('Optimization was stopped with status %d' % status)
        sys.exit(0)

print('\nThe following constraints were removed to get a feasible LP:')
print(removed)
'''
# --------------------------------------------------------------------------------------------------------
lendo = True
print()
while (lendo):
    entrada = input('Entre senha para continuar: ')
    if entrada == 'e':
        lendo = False

# --------------------------------------------------------------------------------------------------------
# Testes de heurística:

c = []
lista_uns = []
for i in range(len(x)):
    c.append(i)
while len(c) != 0:
    valor_da_vez = choice(c)
    c.remove(valor_da_vez)
    lista_uns.append(valor_da_vez)
    for i in range(len(inequacoes)):
        if inequacoes[i][1] != 0:
            if valor_da_vez in inequacoes[i][0]:
                inequacoes[i][0].remove(valor_da_vez)   # Não necessário.
                inequacoes[i][1] = inequacoes[i][1] - 1
                '''
                if inequacoes[i][1] == 0:
                    for valor in inequacoes[i][0]:
                        # if indice != valor_da_vez:
                        try:
                            c.remove(valor)
                        except:
                            pass
                        try:
                            inequacoes[i][0].remove(valor)     # Não necessário.
                        except:
                            pass
                '''
                if inequacoes[i][1] == 0:
                    for valor in inequacoes[i][0]:
                        c.remove(valor)
                        inequacoes[i][0].remove(valor)     # Não necessário.
for i in range(len(inequacoes)):
    print(inequacoes[i])
xx = []
for i in range(len(x)):
    if i in lista_uns:
        xx.append(1)
    else:
        xx.append(0)
# --------------------------------------------------------------------------------------------------------
# Apresentação dos Relatórios (agendas):

p_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][2] not in p_lista:
        p_lista.append(estrela_chaves[cont][2])
tdps_lista = []
for p in p_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][2] == p:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        # if x[tdps_lista[i]].X == 1:
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = nova_grade[l][c]
            info = info + "Turma: " + str(turmas_objetos[estrela_chaves[tdps_lista[i]][0]].numero_turma)\
                + "\n" + "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Professor(a) - heurística: ', professores_objetos[p].nome_professor)
    print(apresentacao)

t_lista = []
for cont in range(len(estrela_chaves)):
    if estrela_chaves[cont][0] not in t_lista:
        t_lista.append(estrela_chaves[cont][0])
tdps_lista = []
for t in t_lista:
    tdps_lista.clear()
    for i in range(len(estrela_chaves)):
        if estrela_chaves[i][0] == t:
            tdps_lista.append(i)
    grade = Grade('1', 'Matutino')
    linhas = grade.grade_vazia()
    nova_grade = copy.deepcopy(linhas)
    for i in range(len(tdps_lista)):
        # if x[tdps_lista[i]].X == 1:
        if xx[tdps_lista[i]] == 1:
            slot_da_vez = int(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            l, c = grade.converte_slot_lc(slot_da_vez)
            info = "Disciplina: " + disciplinas_objetos[estrela_chaves[tdps_lista[i]][1]].nome_disciplina\
                + "\n" + "Professor(a): " + professores_objetos[estrela_chaves[tdps_lista[i]][2]].nome_professor\
                + "\n" + "Slot: " + str(slots_objetos[estrela_chaves[tdps_lista[i]][3]].slot)
            nova_grade[l][c] = info
    cabecalho = grade.cabecalho()
    apresentacao = PrettyTable(grade.cabecalho())
    apresentacao.hrules = True
    apresentacao.left_padding_width = 1
    apresentacao.right_padding_width = 1
    apresentacao.align = 'l'
    apresentacao._max_width = {cabecalho[0]: 30, cabecalho[1]: 30, cabecalho[2]: 30, cabecalho[3]: 30, cabecalho[4]: 30}
    # apresentacao._max_table_width = 150
    for i in range(len(nova_grade)):
        apresentacao.add_row(nova_grade[i])
    print()
    print()
    print('Turma - heurística: ', turmas_objetos[t].numero_turma)
    print(apresentacao)

cont = 0
for i in range(len(x)):
    if x[i].X == 1:
        cont = cont + 1
print('Total de X: ', cont)

cont = 0
for i in range(len(xx)):
    if xx[i] == 1:
        cont = cont + 1
print('Total de xx: ', cont)

print(c)
